# 第十三章 常用的十种算法

## 13.1）二分查找算法(非递归)

### 13.1.1）二分查找算法(非递归)介绍

1. 前面我们讲过了二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式
2. 二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找
3. 二分查找法的运行时间为对数时间`O(㏒₂n)` ，即查找到需要的目标位置**最多**只需要`㏒₂n`步，假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为`㏒₂100` , 即**最多**需要查找7次( `2^6 < 100 < 2^7`)

### 13.1.2）二分查找算法(非递归)代码实现

数组 {1,3, 8, 10, 11, 67, 100}, 编程实现二分查找， 要求使用非递归的方式完成.

**思路分析**：

**代码实现**：

```java
package com.wck.binarysearchnorecursion;

/**
 * 
 * @author YuXiangKaoChi
 * @createTime 2020-05-31 23:00:53
 * 	类说明：二分查找非递归的方式
 */
public class BinarySearchNorecursion {

	public static void main(String[] args) {
		
		int[] arr={1,3, 8, 10, 11, 67, 100};
		
		int binarySearch = binarySearch(arr, -100);
		System.out.println("binarySearch="+binarySearch);
	}
	/**
	 * 二分查找
	 * @param arr 查找的数组
	 * @param target 查找的目标数
	 * @return
	 */
	public static int binarySearch(int[] arr,int target) {
		//最小的左侧下标
		int left=0;
		//右侧的最大下边
		int right=arr.length-1;
		int mid;
		//循环查找
		while (left <= right) {
			//中间的下标索引值
			mid=(left+right)/2;
			if(target == arr[mid]) {//找到了值
				return mid;
			}else if (target < arr[mid]) {//向左进行查找
				right=mid-1;
			}else {//向右查找
				left=mid+1;
			}
		}
		//没有找到，返回 -1 
		return -1;		
	}
}
```

## 13.2）分治算法

### 13.2.1）分治算法介绍

1. 分治法是一种很重要的算法。字面上的解释是“**分而治之**”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法([快速排序](http://www.cnblogs.com/xsyfl/p/6901315.html)，[归并排序](http://www.cnblogs.com/xsyfl/p/6905974.html))，傅立叶变换(快速傅立叶变换)……
2. 分治算法可以**求解的一些经典问题**

- 二分搜索
- 大整数乘法
- 棋盘覆盖
- [合并排序](http://www.cnblogs.com/xsyfl/p/6905974.html)
- [快速排序](http://www.cnblogs.com/xsyfl/p/6901315.html)
- 线性时间选择
- 最接近点对问题
- 循环赛日程表
- **汉诺塔**

### 13.2.2）分治算法的基本步骤

分治法在每一层递归上都有三个步骤：

1. **分解**：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题
2. **解决**：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
3. **合并**：将各个子问题的解合并为原问题的解。

### 13.2.3）分治(Divide-and-Conquer(P))算法设计模式如下

<img src="images/206.png" alt="206" style="zoom: 67%;" />

- 其中`|P|`表示问题P的规模；
- `n0`为一阈值，表示当问题P的规模不超过`n0`时，问题已容易直接解出，不必再继续分解。
- `ADHOC(P)`是该分治法中的基本子算法，用于直接解小规模的问题P。
- 因此，当P的规模不超过n0时直接用算法`ADHOC(P)`求解。
- 算法`MERGE(y1,y2,…,yk)`是该分治法中的合并子算法，用于将P的子问题`P1,P2 ,…,Pk`的相应的解`y1,y2,…,yk`合并为P的解。

### 13.2.4）分治算法最佳实践-汉诺塔

1. 汉诺塔的传说
   汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。

2. 假如每秒钟一次，共需多长时间呢？移完这些金片需要5845.54亿年以上，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。

<img src="images/207.png" alt="207" style="zoom: 80%;" />



### 13.2.5）分治算法最佳实践-汉诺塔-代码实现

#### 13.2.5.1）汉诺塔游戏的思路分析:    

1. 如果是有一个盘， A->C

   如果我们有 n >= 2 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘

2. 先把 最上面的盘 A->B
3. 把最下边的盘 A->C
4. 把B塔的所有盘 从 B->C   

#### 13.2.5.2）汉诺塔游戏的代码实现:   

```java
package com.wck.dac;

/**
 * 
 * @author YuXiangKaoChi
 * @createTime 2020-06-01 15:22:24
 * 类说明：汉诺塔 分治问题
 */
public class HanoiTower {
    //统计次数的变量
	static int count=0;
	public static void main(String[] args) {
		hanoiTower(5, 'A', 'B', 'C');
		System.out.println("总计次数："+count);
	}
	/**
	 * 汉诺塔游戏的演示和思路分析:    
		如果是有一个盘， A->C
		如果我们有 n >= 2 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘
		先把 最上面的盘 A->B
		把最下边的盘 A->C
		把B塔的所有盘 从 B->C   
	 * @param num 总共多少个盘
	 * @param a a柱子
	 * @param b b柱子
	 * @param c c柱子
	 */
	public static void hanoiTower(int num,char a,char b,char c) {
		count++;
		//当盘就一个的时候，直接从 a->c柱子
		if(num == 1) {
			System.out.println("第" + num + "个盘从 " + a + "->" + c);
		}
		//大于等于2的情况，把盘分成两个部分，
		//第一部分是除了最下面的最大盘，其余所有的盘
		//第二部分是最下面的那一个最大盘
		if(num >=2) {
			//1.先把 最上面的盘 A->B
			hanoiTower(num-1, a, c, b);
			//2.把最下边的盘 A->C
			System.out.println("第" + num + "个盘从 " + a + "->" + c);
			//3.把B塔的所有盘 从 B->C   
			hanoiTower(num-1, b, a, c);
		}
	}
}
```

## 13.3）动态规划算法

### 13.3.1）应用场景-背包问题

背包问题：有一个背包，容量为4磅 ，
现有如下物品

| **物品** | **重量** | **价格** |
| -------- | -------- | -------- |
| 吉他(G)  | 1        | 1500     |
| 音响(S)  | 4        | 3000     |
| 电脑(L)  | 3        | 2000     |

1. 要求达到的目标为装入的背包的总价值最大，并且重量不超出
2. 要求装入的物品不能重复

### 13.3.2）动态规划算法介绍

1. 动态规划(**Dynamic Programming**)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法
2. 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。
3. 与分治法不同的是，**适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。** ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )
4. 动态规划可以通过**填表的方式**来逐步推进，得到最优解.

### 13.3.3）动态规划算法最佳实践-背包问题

3. **思路分析和图解**

- 背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包(完全背包指的是：每种物品都有无限件可用)

- 这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包。

算法的**主要思想，利用动态规划来解决**。

1. 每次遍历到的第i个物品，根据w\[i\]和v\[i\]来确定是否需要将该物品放入背包中。
2. 即对于给定的n个物品，设v\[i\]、w\[i\]分别为第i个物品的价值和重量，C为背包的容量。
3. 再令v\[i\]\[j\]表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果：

```java
(1)  v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是0
(2) 当w[i]> j 时：v[i][j]=v[i-1][j]   // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略
(3) 当j>=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]}  
// 当 准备加入的新增的商品的容量小于等于当前背包的容量,
// 装入的方式:
	v[i-1][j]： 就是上一个单元格的装入的最大值
	v[i] : 表示当前商品的价值 
	v[i-1][j-w[i]] ： 装入i-1商品，到剩余空间j-w[i]的最大值
	当j>=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} : 
```

### 13.3.4）背包问题-代码实现

```java
package com.wck.dynamic;

import java.util.Arrays;

/**
 * 
 * @author YuXiangKaoChi
 * @createTime 2020-06-02 14:34:55
 * 类说明：背包问题
 */
public class KnapsackProblem {

	public static void main(String[] args) {
		//物品的重量
		int[] w= {1,4,3};
		//物品的价值
		int[] val= {1500,3000,2000};
		//物品的名称
		String[] gName= {"吉他","音箱","电脑"};
		int m=4;//背包的容量
		int n=val.length;//商品的个数
		//创建二维数组
		//v[i][j] 表示当前从第1个商品到 当前第i个商品中，
		//在背包为j的容量下，所能放下的最大价值
		int[][] v=new int[n+1][m+1];
		
		int[][] path=new int[n+1][m+1];
		
		//(1)  v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是0
		for(int i=0;i<v.length;i++) {
			v[i][0]=0;//处理行
		}
		for(int i=0;i<v[0].length;i++) {
			v[0][i]=0;//处理列
		}
		
		// 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略
		for (int i = 1; i < v.length; i++) {
			for (int j = 1; j < v[0].length; j++) {
				if (w[i - 1] > j) {// 加入的新商品的重量大于背包的容量
					v[i][j] = v[i - 1][j];
				} else {// 当j>=w[i]
						// v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]}  
					//当 准备加入的新增的商品的容量小于等于当前背包的容量,
						// v[i][j]=Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]);
					if (v[i - 1][j] < val[i - 1] + v[i - 1][j - w[i - 1]]) {
						v[i][j]=val[i - 1] + v[i - 1][j - w[i - 1]];
						path[i][j] = 1;
					}else {
						v[i][j]=v[i - 1][j];
					}

				}
			}
		}	
		for (int i = 0; i < v.length; i++) {
			//遍历输出
			System.out.println(Arrays.toString(v[i]));
		}
		System.out.println("path:");
		
		for (int i = 0; i < path.length; i++) { // 遍历输出
			System.out.println(Arrays.toString(path[i]));
		}

		for (int i = 0; i < path.length; i++) {
			for (int j = 0; j < path[i].length; j++) {
				if (path[i][j] == 1) {
					System.out.printf("第%d个商品放入到背包\n", i);
				}
			}
		}		
		int i=path.length-1;//行的最大索引下标
		int j=path[0].length-1;//列的最大索引下标
		System.out.println("最终...");
		while (i > 0 && j>0) {
			if(path[i][j] == 1) {
				System.out.printf("第%d个商品:%s,放入到背包\n", i,gName[i-1]); 
				j -= w[i-1]; //w[i-1]
			}
			i--;
		}
		//物品的重量
		//int[] w= {1,4,3};
		//物品的价值
		//int[] val= {1500,3000,2000};
	}
}
```

## 13.4）KMP算法

### 13.4.1）应用场景-字符串匹配问题

字符串匹配问题：

1)有一个字符串 str1= "界哈哈嗝你好世界啦啦啦啦，和一个子串 str2="哈哈"

2)**现在要判断** **str1** **是否含有** **str2**, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1

### 13.4.2）暴力匹配算法

如果用暴力匹配的思路，并假设现在str1匹配到 i 位置，子串str2匹配到 j 位置，则有:

- 1)如果当前字符匹配成功（即str1\[i\] == str2\[j\]），则i++，j++，继续匹配下一个字符

- 2)如果失配（即str1\[i\]! = str2\[j\]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。

- 3)用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!)

- 4)暴力匹配算法实现.

```java
package com.wck.kmp;

/**
 * 
 * @author YuXiangKaoChi
 * @createTime 2020-06-03 09:48:56
 * 类说明：暴力匹配
 */
public class ViolenceMatch {

	public static void main(String[] args) {
		//源字符串
		String str1="界哈哈嗝你好世界啦啦啦啦";
		//查找的字符串
		String str2="哈哈";
		int match = violenceMatch(str1,str2);
		System.out.println("match="+match);
	}
	/**
	 * 暴力匹配
	 * @param str1 源字符串
	 * @param str2  查找的字符串
	 * @return
	 */
	public static int violenceMatch(String str1,String str2) {
		//转成字符数组
		char[] str1CharArray = str1.toCharArray();
		//转成字符数组
		char[] str2CharArray = str2.toCharArray();
		
		//源字符串的数组长度
		int str1Len=str1CharArray.length;
		//查找字符串的数组长度
		int str2Len=str2CharArray.length;
		int i=0;
		int j=0;	
		while (i < str1Len && j< str2Len) {
			//如果查找到了，则继续下移查找
			if(str1CharArray[i] == str2CharArray[j]) {
				i++;
				j++;
			}else {
				//移动到源字符串的下一个索引，继续查找
				i=i-j+1;
				//把查找的字符串 重新置成索引为0，重新继续查找
				j=0;
			}
		}	
		if(j==str2Len) {
			System.out.println("说明找到了");
			return i-j;
		}	
		return -1;
	}
}
```

### 13.4.3）KMP算法介绍

1)KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法

2)Knuth-Morris-Pratt **字符串查找算法**，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法.

3)KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间

4)参考资料：https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html 

### 13.4.4）KMP算法最佳应用-字符串匹配问题

**字符串匹配问题：**

1)有一个字符串 str1= "BBC ABCDAB ABCDABCDABDE"，和一个子串 str2="ABCDABD"

2)**现在要判断** **str1** **是否含有** **str2**, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1

3)要求：使用KMP算法完成判断，不能使用简单的暴力匹配算法.

> **KMP算法思路分析：**
>
> 举例来说，有一个字符串 `Str1 = “BBC ABCDABABCDABCDABDE”`，判断，里面是否包含另一个字符串 `Str2 = “ABCDABD”`？ 

1. 首先，用`Str1`的第一个字符和`Str2`的第一个字符去比较，不符合，关键词向后移动一位 

<img src="images/208.png" alt="208" style="zoom:80%;" />

2. 重复第一步，还是不符合，再后移 

<img src="images/209.png" alt="209" style="zoom:80%;" />

3. 一直重复，直到Str1有一个字符与Str2的第一个字符符合为止 

<img src="images/210.png" alt="210" style="zoom:80%;" />



4. 接着比较字符串和搜索词的下一个字符，还是符合。

<img src="images/211.png" alt="211" style="zoom:80%;" />

5. 遇到Str1有一个字符与Str2对应的字符不符合

<img src="images/212.png" alt="212" style="zoom:80%;" />



6. 这时候，想到的是继续遍历Str1的下一个字符，重复第1步。(其实是很不明智的，因为此时BCD已经比较过了，没有必要再做重复的工作，一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP 算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。) 

<img src="images/213.png" alt="213" style="zoom:80%;" />

7. 怎么做到把刚刚重复的步骤省略掉？可以对Str2计算出一张《部分匹配表》，这张表的产生在后面介绍 

<img src="images/214.png" alt="214" style="zoom:80%;" />

8. 已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数： 

   移动位数 = 已匹配的字符数 - 对应的部分匹配值 

   因为 6 - 2 等于4，所以将搜索词向后移动 4 位。 

9. 因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移 2 位

<img src="images/215.png" alt="215" style="zoom:80%;" />

10. 因为空格与A不匹配，继续后移一位。 

<img src="images\216.png" alt="216" style="zoom:80%;" />

11. 逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动 4 位。 

<img src="images/217.png" alt="217" style="zoom:80%;" />

12. 逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动 7 位，这里就不再重复了。

<img src="images/218.png" alt="218" style="zoom:80%;" />

13. 介绍《部分匹配表》怎么产生的 

先介绍前缀，后缀是什么 

<img src="images/219.png" alt="219" style="zoom:80%;" />

“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”`ABCDABD`”为例， 

－”`A`”的前缀和后缀都为空集，共有元素的长度为0； 

－”`AB`”的前缀为`[A]`，后缀为`[B]`，共有元素的长度为0； 

－”`ABC`”的前缀为`[A, AB]`，后缀为`[BC, C]`，共有元素的长度0； 

－”`ABCD`”的前缀为`[A, AB, ABC]`，后缀为`[BCD, CD, D]`，共有元素的长度为0； 

－”`ABCDA`”的前缀为`[A, AB, ABC, ABCD]`，后缀为`[BCDA, CDA, DA, A]`，共有元素为”`A`”，长度为1； 

－”`ABCDAB`”的前缀为`[A, AB, ABC, ABCD, ABCDA]`，后缀为`[BCDAB, CDAB, DAB, AB, B]`，共有元素为”`AB`”，长度为2； 

－”`ABCDABD`”的前缀为`[A, AB, ABC, ABCD, ABCDA, ABCDAB]`，后缀为`[BCDABD, CDABD, DABD, ABD, BD, D]`，共有元素的长度为0。 

14. ”部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动 4 位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。 

<img src="images/214.png" alt="214" style="zoom:80%;" />

到此KMP算法思想分析完毕!

### 13.4.5）KMP算法最佳应用-代码实现

```java
package com.wck.kmp;

import java.util.Arrays;

public class KMPAlgorithm {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		String str1 = "BBC ABCDAB ABCDABCDABDE";
		String str2 = "ABCDABD";
		//String str2 = "BBC";
		
		int[] next = kmpNext("ABCDABD"); //[0, 1, 2, 0]
		System.out.println("next=" + Arrays.toString(next));
		
		int index = kmpSearch(str1, str2, next);
		System.out.println("index=" + index); // 15了
	}
	//写出我们的kmp搜索算法
	/**
	 * 
	 * @param str1 源字符串
	 * @param str2 子串
	 * @param next 部分匹配表, 是子串对应的部分匹配表
	 * @return 如果是-1就是没有匹配到，否则返回第一个匹配的位置
	 */
	public static int kmpSearch(String str1, String str2, int[] next) {
		
		//遍历 
		for(int i = 0, j = 0; i < str1.length(); i++) {
			
			//需要处理 str1.charAt(i) ！= str2.charAt(j), 去调整j的大小
			//KMP算法核心点, 可以验证...
			while( j > 0 && str1.charAt(i) != str2.charAt(j)) {
				j = next[j-1]; 
			}
			
			if(str1.charAt(i) == str2.charAt(j)) {
				j++;
			}			
			if(j == str2.length()) {//找到了 // j = 3 i 
				return i - j + 1;
			}
		}
		return  -1;
	}
	//获取到一个字符串(子串) 的部分匹配值表
	public static  int[] kmpNext(String dest) {
		//创建一个next 数组保存部分匹配值
		int[] next = new int[dest.length()];
		next[0] = 0; //如果字符串是长度为1 部分匹配值就是0
		for(int i = 1, j = 0; i < dest.length(); i++) {
			//当dest.charAt(i) != dest.charAt(j) ，我们需要从next[j-1]获取新的j
			//直到我们发现 有  dest.charAt(i) == dest.charAt(j)成立才退出
			//这时kmp算法的核心点
			while(j > 0 && dest.charAt(i) != dest.charAt(j)) {
				j = next[j-1];
			}
			
			//当dest.charAt(i) == dest.charAt(j) 满足时，部分匹配值就是+1
			if(dest.charAt(i) == dest.charAt(j)) {
				j++;
			}
			next[i] = j;
		}
		return next;
	}
}
```

## 13.4）贪心算法

### 13.4.1）贪心算法介绍

1. 贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法

2. 贪婪算法所得到的结果**不一定是最优的结果(有时候会是最优解)**，但是都是相对近似(接近)最优解的结果

### 13.4.2）应用场景-集合覆盖问题

1. 假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。 **如何选择最少的广播台**，让所有的地区都可以接收到信号

| 广播台 | 覆盖地区               |
| ------ | ---------------------- |
| K1     | "北京", "上海", "天津" |
| K2     | "广州", "北京", "深圳" |
| K3     | "成都", "上海", "杭州" |
| K4     | "上海", "天津"         |
| K5     | "杭州", "大连"         |

2. **思路分析:** 

- 如何找出覆盖所有地区的广播台的集合呢，使用穷举法实现,列出每个可能的广播台的集合，这被称为幂集。假设总的有n个广播台，则广播台的组合总共有2ⁿ -1 个,假设每秒可以计算10个子集，
  如图:

| 广播台数量n | 子集总数2ⁿ | 需要的时间 |
| ----------- | ---------- | ---------- |
| 5           | 32         | 3.2秒      |
| 10          | 1024       | 102.4秒    |
| 32          | 4294967296 | 13.6年     |
| 100         | 1.26*100³º | 4x10²³年   |

- 使用贪婪算法，效率高:

**目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合:**

1)遍历所有的广播电台, 找到一个覆盖了最多**未覆盖的地区**的电台(此电台可能包含一些已覆盖的地区，但没有关系） 

2)将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。

3)重复第1步直到覆盖了全部的地区

<img src="images/220.png" alt="220" style="zoom:80%;" />

### 13.4.3)代码实现贪心算法案例

```java
package com.wck.greedy;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map.Entry;
import java.util.Set;

/**
 * 
 * @author YuXiangKaoChi
 * @createTime 2020-06-04 19:19:03
 * 	类说明：贪心算法
 */
public class GreedyAlgorithm {

	public static void main(String[] args) {
		//存放所有电台频道和地区的map
		HashMap<String, Set<String>> broadcastMap = new HashMap<String, Set<String>>();
		
		HashSet<String> hashSet1 = new HashSet<String>();
		hashSet1.add("北京");
		hashSet1.add("上海");
		hashSet1.add("天津");
		
		HashSet<String> hashSet2 = new HashSet<String>();
		hashSet2.add("广州");
		hashSet2.add("北京");
		hashSet2.add("深圳");
		
		HashSet<String> hashSet3 = new HashSet<String>();
		hashSet3.add("成都");
		hashSet3.add("上海");
		hashSet3.add("杭州");
		
		HashSet<String> hashSet4 = new HashSet<String>();
		hashSet4.add("上海");
		hashSet4.add("天津");

		
		HashSet<String> hashSet5 = new HashSet<String>();
		hashSet5.add("杭州");
		hashSet5.add("大连");
		
		
		broadcastMap.put("K1", hashSet1);
		broadcastMap.put("K2", hashSet2);
		broadcastMap.put("K3", hashSet3);
		broadcastMap.put("K4", hashSet4);
		broadcastMap.put("K5", hashSet5);
		
		//System.out.println(broadcastMap);
		
		//存放所有地区的HashSet
		Set<String> allArea = new HashSet<String>();
		for (Entry<String, Set<String>> b:broadcastMap.entrySet()) {
			//System.out.println("key:"+b.getKey()+",val:"+b.getValue());
			allArea.addAll(b.getValue());
		}
		
		System.out.println(allArea);
		//存放最后的电台结果
		ArrayList<String> resultList = new ArrayList<String>();
		//用于存放每一轮的缓存set
		Set<String> tempHashSet = new HashSet<String>();
		
		//包含的最大城市的标记 maxKey
		String maxKey=null;
		//用于记录每轮中最大值 最大包含 城市的个数
		int maxKeySize = 0;
		
		while (allArea.size() > 0) {
			maxKey=null;
			for (Entry<String, Set<String>> b:broadcastMap.entrySet()) {
				//System.out.println("key:"+b.getKey()+",val:"+b.getValue());
				tempHashSet.clear();
//				tempHashSet=b.getValue();
				tempHashSet.addAll(b.getValue());
				//取交集的部分
				tempHashSet.retainAll(allArea);
				if(maxKey !=null) {
					//获取最大maxKey所包含的城市
					Set<String> maxKeySet = broadcastMap.get(maxKey);
					//和当前的所有城市取交集
					maxKeySet.retainAll(allArea);
					maxKeySize=maxKeySet.size();
				}
				//如果 交集中的个数大于0 并且（maxKey 不为 null 或者 交集中的个数大于 最大的maxKeySize）
				if(tempHashSet.size() > 0 && (maxKey== null || tempHashSet.size() > maxKeySize)) {
					//赋值最大个数的key
					maxKey=b.getKey();
				}
			}	
			if(maxKey !=null) {
				//把maxKey加入到结果集合
				resultList.add(maxKey);
				//从所有地区中取出已经加入到结果集合的地区
				allArea.removeAll(broadcastMap.get(maxKey));
				
			}
			
		}	
		System.out.println("最后的结果为resultList："+resultList);	
	}
}
```

### 13.4.4）贪心算法注意事项和细节

1. (1)**贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结**

2. (2)**比如上题的**算法选出的是K1, K2, K3, K5，符合覆盖了全部的地区

3. (3)但是我们发现 K2, K3,K4,K5 也可以覆盖全部地区，如果K2 的使用成本低于K1,那么我们上题的 K1, K2, K3, K5 虽然是满足条件，但是并不是最优的.

## 13.5）普里姆算法



















































