# 第六章 递归

## 6.1）递归应用场景

看个实际应用场景，**迷宫问题(回溯)， 递归(Recursion)**

![31](D:/githubRepositories/notes/数据结构和算法/images/31.png)



## 6.2）递归的概念

简单的说: 递归就是**方法自己调用自己**,**每次调用时传入不同的变量**.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。

## 6.3）递归调用机制

**递归调用机制**

- 1）打印问题
- 2）阶乘问题

- 打印问题

```java
//输出什么? test(4)
public static void test(int n) {
if (n > 2) {
	test(n - 1);
}
System.out.println("n=" + n);
}
//n=2
//n=3
//n=4
```

![32](D:/githubRepositories/notes/数据结构和算法/images/32.png)



- 阶乘问题

```java
//阶乘 factorial(3) =3*2*1 =6
public static int factorial(int n) {
if (n == 1) {
return 1;
} else {
return factorial(n - 1) * n;
}}

```

## 6.4）递归能解决什么样的问题

- 1）各种数学问题如: 8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google编程大赛)
- 2）各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.
- 3）将用栈解决的问题-->第归代码比较简洁

## 6.5）递归需要遵守的重要规则

- 1）执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
- 2）**方法的局部变量是独立的**，不会**相互影响, 比如n变量**
- 3）如果**方法中使用的是引用类型变量(比如数组)**，就**会共享该引用类型的数据.**
  递归**必须向退出递归的条件逼近**，**否则就是无限递归**,出现StackOverflowError，死龟了:)
- 4）当**一个方法执行完毕，或者遇到return**，就**会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。**

## 6.6）递归-迷宫问题

### 6.6.1）迷宫问题说明

![31](images/31.png)

### 6.6.2）迷宫问题代码实现

```java
package com.wck.recursion;
/**
* @author YuXiangKaoChi
* @createTime：2020-05-01 18:38:34
*   类说明：迷宫问题
*/


public class MiGong {

	public static void main(String[] args) {

		//首先画出数组
		int[][] map=new int[8][7];
		for(int i=0;i<7;i++) {
			map[0][i]=1;
			map[7][i]=1;
		}
		for(int i=0;i<8;i++) {
			map[i][0]=1;
			map[i][6]=1;
		}
		map[3][1]=1;
		map[3][2]=1;
//		map[1][2]=1;
//		map[2][2]=1;
		System.out.println("打印遍历数组：");
		list(map);
		
		System.out.println("--------------------------");
		
		setWay2(map, 1, 1);
		System.out.println("打印探测遍历数组：");
		list(map);
		
	}

	/**
	 * 遍历打印数组
	 * @param map
	 */
	public static void list(int[][] map) {
		for(int i=0;i<map.length;i++) {
			for (int j = 0; j < map[0].length; j++) {
				System.out.print(map[i][j]+" ");
			}
			System.out.println();
		}
	}
	
	/**
	 * 规定：
	 * 1 map 表示地图
	 * 2 i,j表示从地图的那个位置出发 (1,1)
	 * 3  如果小球能到map[6][5]位置，则说明通路找到
	 * 4  约定：
	 * 	 	   当map[i][j] 为 0  表示该点，没有走过。当为1 时表示墙，2  表示通路可以走，
	 * 		  3 表示已经走过，但是走不通
	 * 5 在走迷宫时，需确定一个策略（方法）下->右->上->左，如果该点走不通再回溯
	 */
	/**
	 * @param map  需要找的数组
	 * @param i    路径的起点 行
	 * @param j    路径的起点 列
	 * @return     是否已经走通
	 */
	public static boolean setWay(int[][] map,int i,int j) {
		if(map[6][5] == 2) {//已经找到了终点，并且走的通
			return true;
		}else {
			if(map[i][j] == 0) {
				map[i][j]=2;//先定义成走的通
				if(setWay(map, i+1, j)) {//向下走
					return true;
				}else if (setWay(map, i, j+1)) {//向右走
					return true;
				}else if (setWay(map, i-1, j)) {//向上走
					return true;
				}else if (setWay(map, i, j-1)) {//向左走
					return true;
				}else {
					map[i][j]=3;//路走不通
					return false;
				}
			}else {
				//如果map[i][j] 不为0 可能是 1 2 3 则直接返回 false
				return false;
			}
		}
	}
	
	/**
	 * 规则策略改成上右下左
	 * @param map
	 * @param i
	 * @param j
	 * @return
	 */
	public static boolean setWay2(int[][] map,int i,int j) {
		if(map[6][5] == 2) {//已经找到了终点，并且走的通
			return true;
		}else {
			if(map[i][j] == 0) {
				map[i][j]=2;//先定义成走的通
				if(setWay2(map, i-1, j)) {//向上走
					return true;
				}else if (setWay2(map, i, j+1)) {//向右走
					return true;
				}else if (setWay2(map, i+1, j)) {//向下走
					return true;
				}else if (setWay2(map, i, j-1)) {//向左走
					return true;
				}else {
					map[i][j]=3;//路走不通
					return false;
				}
			}else {
				//如果map[i][j] 不为0 可能是 1 2 3 则直接返回 false
				return false;
			}
		}
	}
}
```

### 6.6.3）对迷宫问题的讨论

说明:     

- 1）小球得到的路径，和程序员设置的**找路策略有关**即：找路的上下左右的顺序相关
- 2）再得到小球路径时，可以先使用(**下右上左)**，再改成(**上右下左**)，看看路径是不是有变化
- 3）测试回溯现象
- 4**）思考: 如何求出最短路径?**  把上下左右可能的情况，放在数组中，遍历所有可能的情况，然后把走的每一步都加入到步数的数组中，最后看 那个的 2比较少，就是最短的路径







