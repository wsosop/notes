# 第十章 树结构基础部分

## 10.1）二叉树

### 10.1.1）为什么需要树这种数据结构

- 1）数组存储方式的分析
  优点：通过下标方式访问元素，速度快。**对于有序数组**，还可使用二分查找提高检索速度。
  缺点：如果要检索具体某个值，或者插入值(按一定顺序)**会整体移动**，效率较低
  ![67](images/67.png)
- 链式存储方式的分析
  优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可，
  删除效率也很好)。
  缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)

![68](images/68.png)

- 1)**树**存储方式的分析
  能提高数据**存储，读取**的效率,  比如利用 **二叉排序树**(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。【示意图,后面详讲】

**案例:\[7,3, 10, 1, 5, 9, 12\]**

![69](images/69.png)

### 10.1.2）树示意图

<img src="images/70.png" alt="70" style="zoom:80%;" />

**树的常用术语(结合示意图理解):**       

- 1)节点
- 2)根节点
- 3)父节点
- 4)子节点
- 5)叶子节点 (没有子节点的节点)
- 6)节点的权(节点值)
- 7)路径(从root节点找到该节点的路线)
- 8)层
- 9)子树
- 10)树的高度(最大层数)
- 11)森林 :多颗子树构成森林

### 10.1.3）二叉树的概念

1)树有很多种，每个节点**最多只能有两个子节点**的一种形式称为二叉树。      

2)二叉树的子节点分为左节点和右节点。    

<img src="images/71.png" alt="71" style="zoom:80%;" />

3)如果该二叉树的**所有叶子节点都在最后一层**，并且结点总数= 2^n -1 , n 为层数，则我们称为**满二叉树**。      

4)如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为**完全二叉树。**

![72](images/72.png)

### 10.1.4）二叉树(前、中、后、序)遍历的说明

使用**前序**，**中序**和**后序**对下面的二叉树进行遍历

![73](images/73.png)

前序遍历: **先输出父节点**，再遍历左子树和右子树      

中序遍历: 先遍历左子树，**再输出父节点**，再遍历右子树      

后序遍历: 先遍历左子树，再遍历右子树，**最后输出父节点 **      

**小结**: 看输出父节点的顺序，就确定是前序，中序还是后序     

### 10.1.5）二叉树遍历应用实例(前序,中序,后序)

<img src="images/74.png" alt="74" style="zoom:80%;" />

### 10.1.6）代码实现

```java
package com.wck.tree;

/**
 * @author YuXiangKaoChi
 * @createTime 2020-05-16 17:41:55 类说明： 前中后序
 */
public class BinaryTreeDemo {
	
	public static void main(String[] args) {
		//构造节点
		HeroNode root = new HeroNode(1, "宋江");
		HeroNode node2 = new HeroNode(2, "吴用");
		HeroNode node3 = new HeroNode(3, "卢俊义");
		HeroNode node4 = new HeroNode(4, "林冲");
		HeroNode node5 = new HeroNode(5, "关胜");
		
		//树的关系建立
		root.setLeft(node2);
		root.setRight(node3);
		
		node3.setLeft(node5);
		node3.setRight(node4);
		
		BinaryTree binaryTree = new BinaryTree();
		binaryTree.setRoot(root);
		System.out.println("前序遍历：");
		binaryTree.prevOrder();
		System.out.println("中序遍历：");
		binaryTree.infixOrder();
		System.out.println("后序遍历：");
		binaryTree.postOrder();
		
	}
	

}

//二叉树
class BinaryTree {
	// 根节点
	private HeroNode root;

	public void setRoot(HeroNode root) {
		this.root = root;
	}

	// 前序遍历
	public void prevOrder() {
		this.root.prevOrder();
	}

	// 中序遍历
	public void infixOrder() {
		this.root.infixOrder();
	}

	// 后序遍历
	public void postOrder() {
		this.root.postOrder();
	}

}


//英雄节点类
class HeroNode {
	// 英雄编号
	private int no;
	// 英雄姓名
	private String name;

	// 左边的节点
	private HeroNode left;
	// 右边的节点
	private HeroNode right;

	public HeroNode(int no, String name) {
		this.no = no;
		this.name = name;
	}

	public int getNo() {
		return no;
	}

	public void setNo(int no) {
		this.no = no;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public HeroNode getLeft() {
		return left;
	}

	public void setLeft(HeroNode left) {
		this.left = left;
	}

	public HeroNode getRight() {
		return right;
	}

	public void setRight(HeroNode right) {
		this.right = right;
	}

	@Override
	public String toString() {
		return "HeroNode [no=" + no + ", name=" + name + "]";
	}

	// 前序遍历(根左右)
	public void prevOrder() {
		// 输出根节点
		// 根
		System.out.println(this);
		// 左
		if (this.left != null) {
			this.left.prevOrder();
		}
		// 右
		if (this.right != null) {
			this.right.prevOrder();
		}
	}

	// 中序遍历(左根右)
	public void infixOrder() {
		// 左
		if (this.left != null) {
			this.left.infixOrder();
		}
		// 根
		System.out.println(this);
		// 右
		if (this.right != null) {
			this.right.infixOrder();
		}
	}
	// 后序遍历(左右根)
	public void postOrder() {
		// 左
		if (this.left != null) {
			this.left.postOrder();
		}
		// 右
		if (this.right != null) {
			this.right.postOrder();
		}
		// 根
		System.out.println(this);
	}
}
```

### 10.1.7）二叉树-查找指定节点

**要求**

- 1)请编写前序查找，中序查找和后序查找的方法。
- 2)并分别使用三种查找方式，查找 heroNO = 5 的节点
- 3)并分析各种查找方式，分别比较了多少次

### 10.1.8）二叉树-查找指定节点-分析

![75](images/75.png)

用前序，中序，后序的方式来查询指定的结点

- 前序查找思路         

1.先判断当前结点的no是否等于要查找的          

2.如果是相等，则返回当前结点

3.如果不等，则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找

4.如果左递归前序查找，找到结点，则返回，否则继续判断，当前的结点的右子节点是否为空，如果不为空，则继续向右递归前序查找

- 中序查找思路

1.判断当前结点的左子节点是否为空，如果不为空，则递归中序查找

2.如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点，否则继续进行右递归的中序查找

3.如果右递归中序查找，找到就返回，否则返回null

- 后序查找思路

1.判断当前结点的左子节点是否为空，如果不为空，则递归后序查找

2.如果找到，就返回，如果没有找到，就判断当前结点的右子节点是否为空，如果不为空，则右递归进行后序查找，如果找到，就返回

3.就和当前结点进行，比如，如果是则返回，否则返回null

### 10.1.8）二叉树-查找指定节点-代码实现

```java
package com.wck.tree;

/**
 * @author YuXiangKaoChi
 * @createTime 2020-05-16 17:41:55 类说明： 前中后序
 */
public class BinaryTreeDemo {
	
	public static void main(String[] args) {
		//构造节点
		HeroNode root = new HeroNode(1, "宋江");
		HeroNode node2 = new HeroNode(2, "吴用");
		HeroNode node3 = new HeroNode(3, "卢俊义");
		HeroNode node4 = new HeroNode(4, "林冲");
		HeroNode node5 = new HeroNode(5, "关胜");
		
		//树的关系建立
		root.setLeft(node2);
		root.setRight(node3);
		
		node3.setLeft(node5);
		node3.setRight(node4);
		
		BinaryTree binaryTree = new BinaryTree();
		binaryTree.setRoot(root);
		System.out.println("前序遍历：");
		binaryTree.prevOrder();
		System.out.println("中序遍历：");
		binaryTree.infixOrder();
		System.out.println("后序遍历：");
		binaryTree.postOrder();
		
		//前中后序的查找
		//前序查找 次数 4
		int no=5;
		/*
		System.out.println("前序查找:");
		HeroNode resNode = binaryTree.prevOrderSearch(no);
		if(resNode != null) {
			System.out.println("找到了："+resNode.toString());
		}else {
			System.out.println("没有找到，no："+no);
		}
		*/

		/*
		//中序查找 次数 3
		System.out.println("中序查找:");
		HeroNode resNode2 = binaryTree.infixOrderSearch(no);
		if(resNode2 != null) {
			System.out.println("找到了："+resNode2.toString());
		}else {
			System.out.println("没有找到，no："+no);
		}
		*/
		//后序查找 次数 2
		System.out.println("后序查找:");
		HeroNode resNode3 = binaryTree.postOrderSearch(no);
		if (resNode3 != null) {
			System.out.println("找到了：" + resNode3.toString());
		} else {
			System.out.println("没有找到，no：" + no);
		}
	}
	

}

//二叉树
class BinaryTree {
	// 根节点
	private HeroNode root;

	public void setRoot(HeroNode root) {
		this.root = root;
	}

	// 前序遍历
	public void prevOrder() {
		this.root.prevOrder();
	}

	// 中序遍历
	public void infixOrder() {
		this.root.infixOrder();
	}

	// 后序遍历
	public void postOrder() {
		this.root.postOrder();
	}
	
	
	//前序查找
	public HeroNode prevOrderSearch(int no) {
		return this.root.prevOrderSearch(no);
	}
	
	//中序查找
	public HeroNode infixOrderSearch(int no) {
		return this.root.infixOrderSearch(no);
	}
	
	//后序查找
	public HeroNode postOrderSearch(int no) {
		return this.root.postOrderSearch(no);
	}

}

//英雄节点类
class HeroNode {
	// 英雄编号
	private int no;
	// 英雄姓名
	private String name;

	// 左边的节点
	private HeroNode left;
	// 右边的节点
	private HeroNode right;

	public HeroNode(int no, String name) {
		this.no = no;
		this.name = name;
	}

	public int getNo() {
		return no;
	}

	public void setNo(int no) {
		this.no = no;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public HeroNode getLeft() {
		return left;
	}

	public void setLeft(HeroNode left) {
		this.left = left;
	}

	public HeroNode getRight() {
		return right;
	}

	public void setRight(HeroNode right) {
		this.right = right;
	}

	@Override
	public String toString() {
		return "HeroNode [no=" + no + ", name=" + name + "]";
	}

	// 前序遍历(根左右)
	public void prevOrder() {
		// 输出根节点
		// 根
		System.out.println(this);
		// 左
		if (this.left != null) {
			this.left.prevOrder();
		}
		// 右
		if (this.right != null) {
			this.right.prevOrder();
		}
	}

	// 中序遍历(左根右)
	public void infixOrder() {
		// 左
		if (this.left != null) {
			this.left.infixOrder();
		}
		// 根
		System.out.println(this);
		// 右
		if (this.right != null) {
			this.right.infixOrder();
		}
	}

	// 后序遍历(左右根)
	public void postOrder() {
		// 左
		if (this.left != null) {
			this.left.postOrder();
		}
		// 右
		if (this.right != null) {
			this.right.postOrder();
		}
		// 根
		System.out.println(this);
	}
	
	//前序遍历查找(根左右)
	public HeroNode prevOrderSearch(int no) {
		System.out.println("前序查找次数");
		//查找根
		if(this.no == no) {
			return this;
		}
		HeroNode resNode=null;
		//左查找
		if(this.left !=null) {
			resNode=this.left.prevOrderSearch(no);
		}
		
		//左边的分支节点找到
		if(resNode != null) {
			return resNode;
		}
		
		//右查找
		if(this.right !=null) {
			resNode=this.right.prevOrderSearch(no);
		}
		return resNode;
	}
	
	//中序遍历查找(左根右)
	public HeroNode infixOrderSearch(int no) {
		HeroNode resNode = null;
		// 左查找
		if (this.left != null) {
			resNode = this.left.infixOrderSearch(no);
		}
		// 左边的分支节点找到
		if (resNode != null) {
			return resNode;
		}
		System.out.println("中序查找次数");
		// 查找根
		if (this.no == no) {
			return this;
		}

		// 右查找
		if (this.right != null) {
			resNode = this.right.infixOrderSearch(no);
		}
		return resNode;
	}
	
	// 后序遍历查找(左右根)
	public HeroNode postOrderSearch(int no) {
		HeroNode resNode = null;
		// 左查找
		if (this.left != null) {
			resNode = this.left.postOrderSearch(no);
		}
		// 左边的分支节点找到
		if (resNode != null) {
			return resNode;
		}

		// 右查找
		if (this.right != null) {
			resNode = this.right.postOrderSearch(no);
		}
		// 右边的分支节点找到
		if (resNode != null) {
			return resNode;
		}
		System.out.println("后序查找次数");
		// 查找根
		if (this.no == no) {
			return this;
		}
		return resNode;
	}
	
}
```

### 10.1.9）二叉树-删除节点

**要求**          

- 1)如果删除的节点是叶子节点，则删除该节点
- 2)如果删除的节点是非叶子节点，则删除该子树.
- 3)测试，删除掉 5号叶子节点 和 3号子树.

### 10.1.10）二叉树-删除节点-思路分析

![76](images/76.png)



**完成删除结点的操作**

- 规定：
  - 1）如果删除的节点是叶子节点，则删除该节点
  - 2）如果删除的节点是非叶子节点，则删除该子树
- 思路
  首先先处理：
  - 考虑如果树是空树root，如果只有一个root结点，则等价将二又树置空
    //然后进行下面步骤
  - 1.因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.
  - 2.如果当前结点的左子结点不为空，并且左子结点就是要删除结点，就将this.left=null并且就返回（结束递归删除）
  - 3.如果当前结点的右子结点不为空，并且右子结点就是要删除结点，就将this.right=null；并且就返回（结束递归删除）
  - 4.如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除
  - 5.如果第4步也没有删除结点，则应当向右子树进行递归删除.

### 10.1.11）二叉树-删除节点-代码完成

```java
package com.wck.tree;

/**
 * @author YuXiangKaoChi
 * @createTime 2020-05-16 17:41:55 类说明： 前中后序
 */
public class BinaryTreeDemo {
	
	public static void main(String[] args) {
		//构造节点
		HeroNode root = new HeroNode(1, "宋江");
		HeroNode node2 = new HeroNode(2, "吴用");
		HeroNode node3 = new HeroNode(3, "卢俊义");
		HeroNode node4 = new HeroNode(4, "林冲");
		HeroNode node5 = new HeroNode(5, "关胜");
		
		//树的关系建立
		root.setLeft(node2);
		root.setRight(node3);
		
		node3.setLeft(node5);
		node3.setRight(node4);
		
		BinaryTree binaryTree = new BinaryTree();
		binaryTree.setRoot(root);
		/*
		binaryTree.setRoot(root);
		System.out.println("前序遍历：");
		binaryTree.prevOrder();
		System.out.println("中序遍历：");
		binaryTree.infixOrder();
		System.out.println("后序遍历：");
		binaryTree.postOrder();
		*/
		
		//前中后序的查找
		//前序查找 次数 4
		/*int no=5;
		System.out.println("前序查找:");
		HeroNode resNode = binaryTree.prevOrderSearch(no);
		if(resNode != null) {
			System.out.println("找到了："+resNode.toString());
		}else {
			System.out.println("没有找到，no："+no);
		}
		*/

		/*
		//中序查找 次数 3
		System.out.println("中序查找:");
		HeroNode resNode2 = binaryTree.infixOrderSearch(no);
		if(resNode2 != null) {
			System.out.println("找到了："+resNode2.toString());
		}else {
			System.out.println("没有找到，no："+no);
		}
		*/
		/*
		//后序查找 次数 2
		System.out.println("后序查找:");
		HeroNode resNode3 = binaryTree.postOrderSearch(no);
		if (resNode3 != null) {
			System.out.println("找到了：" + resNode3.toString());
		} else {
			System.out.println("没有找到，no：" + no);
		}
		*/
		
		//测试，删除掉 5号叶子节点 和 3号子树.
		System.out.println("删除前的前序为：");
		binaryTree.prevOrder();
		System.out.println("删除后的前序为：");
		binaryTree.delNode(5);
		binaryTree.prevOrder();
		
		
	}
	

}

//二叉树
class BinaryTree {
	// 根节点
	private HeroNode root;

	public void setRoot(HeroNode root) {
		this.root = root;
	}

	// 前序遍历
	public void prevOrder() {
		this.root.prevOrder();
	}

	// 中序遍历
	public void infixOrder() {
		this.root.infixOrder();
	}

	// 后序遍历
	public void postOrder() {
		this.root.postOrder();
	}
	
	
	//前序查找
	public HeroNode prevOrderSearch(int no) {
		return this.root.prevOrderSearch(no);
	}
	
	//中序查找
	public HeroNode infixOrderSearch(int no) {
		return this.root.infixOrderSearch(no);
	}
	
	//后序查找
	public HeroNode postOrderSearch(int no) {
		return this.root.postOrderSearch(no);
	}
	
	//删除节点
	public void delNode(int no) {
		//先判断根节点是否为null
		if(root!= null) {
			//根节点的no和待删除的no一样，直接删除
			if(root.getNo() == no) {
				root=null;
			}else {
				//查找删除
				root.delNode(no);
			}
		}else {
			System.out.println("该根节点为空，不能再删除了");
		}
		
	}

}

//英雄节点类
class HeroNode {
	// 英雄编号
	private int no;
	// 英雄姓名
	private String name;

	// 左边的节点
	private HeroNode left;
	// 右边的节点
	private HeroNode right;

	public HeroNode(int no, String name) {
		this.no = no;
		this.name = name;
	}

	public int getNo() {
		return no;
	}

	public void setNo(int no) {
		this.no = no;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public HeroNode getLeft() {
		return left;
	}

	public void setLeft(HeroNode left) {
		this.left = left;
	}

	public HeroNode getRight() {
		return right;
	}

	public void setRight(HeroNode right) {
		this.right = right;
	}

	@Override
	public String toString() {
		return "HeroNode [no=" + no + ", name=" + name + "]";
	}

	// 前序遍历(根左右)
	public void prevOrder() {
		// 输出根节点
		// 根
		System.out.println(this);
		// 左
		if (this.left != null) {
			this.left.prevOrder();
		}
		// 右
		if (this.right != null) {
			this.right.prevOrder();
		}
	}

	// 中序遍历(左根右)
	public void infixOrder() {
		// 左
		if (this.left != null) {
			this.left.infixOrder();
		}
		// 根
		System.out.println(this);
		// 右
		if (this.right != null) {
			this.right.infixOrder();
		}
	}

	// 后序遍历(左右根)
	public void postOrder() {
		// 左
		if (this.left != null) {
			this.left.postOrder();
		}
		// 右
		if (this.right != null) {
			this.right.postOrder();
		}
		// 根
		System.out.println(this);
	}
	
	
	//前序遍历查找(根左右)
	public HeroNode prevOrderSearch(int no) {
		System.out.println("前序查找次数");
		//查找根
		if(this.no == no) {
			return this;
		}
		HeroNode resNode=null;
		//左查找
		if(this.left !=null) {
			resNode=this.left.prevOrderSearch(no);
		}
		
		//左边的分支节点找到
		if(resNode != null) {
			return resNode;
		}
		
		//右查找
		if(this.right !=null) {
			resNode=this.right.prevOrderSearch(no);
		}
		return resNode;
	}
	
	//中序遍历查找(左根右)
	public HeroNode infixOrderSearch(int no) {
		HeroNode resNode = null;
		// 左查找
		if (this.left != null) {
			resNode = this.left.infixOrderSearch(no);
		}
		// 左边的分支节点找到
		if (resNode != null) {
			return resNode;
		}
		System.out.println("中序查找次数");
		// 查找根
		if (this.no == no) {
			return this;
		}

		// 右查找
		if (this.right != null) {
			resNode = this.right.infixOrderSearch(no);
		}
		return resNode;
	}
	
	// 后序遍历查找(左右根)
	public HeroNode postOrderSearch(int no) {
		HeroNode resNode = null;
		// 左查找
		if (this.left != null) {
			resNode = this.left.postOrderSearch(no);
		}
		// 左边的分支节点找到
		if (resNode != null) {
			return resNode;
		}

		// 右查找
		if (this.right != null) {
			resNode = this.right.postOrderSearch(no);
		}
		// 右边的分支节点找到
		if (resNode != null) {
			return resNode;
		}
		System.out.println("后序查找次数");
		// 查找根
		if (this.no == no) {
			return this;
		}

		return resNode;
	}
	
	//删除节点
	//传递待删除的no
	public void delNode(int no) {
		//要求的规则
		//如果删除的节点是叶子节点，则删除该节点
		//如果删除的节点是非叶子节点，则删除该子树.
		//测试，删除掉 5号叶子节点 和 3号子树.

		//先判断左边的是否是待删除的节点
		if(this.left !=null && this.left.no == no) {
			this.left=null;
		}
		
		//判断右边的是否是待删除的节点
		if(this.right != null && this.right.no == no) {
			this.right=null;
		}
		
		//向左节点递归
		if(this.left !=null) {
			this.left.delNode(no);
		}
		// 向右节点递归
		if (this.right != null) {
			this.right.delNode(no);
		}
	}
	
}
```

### 10.1.12）二叉树-删除节点-附加思考题

- 1)如果要删除的节点是非叶子节点，现在我们不希望将该非叶子节点为根节点的子树删除，**需要指定规则,假如规定如下**:
- 2)如果该非叶子节点A只有一个子节点B，则子节点B替代节点A    
- 3)如果该非叶子节点A有左子节点B和右子节点C，则让左子节点B替代节点A。
- 4)思考，如何完成该删除功能,

### 10.1.13）顺序存储二叉树

#### 10.1.13.1）顺序存储二叉树的概念

- 基本说明

从数据存储来看，**数组存储方式和树的存储方式**可以相互转换，即数组可以转换成树，树也可以转换成数组，看下面的示意图。

<img src="images/77.png" alt="77" style="zoom:67%;" />

- 要求:

1)右图的二叉树的结点，要求以数组的方式来存放 arr : [1, 2, 3, 4, 5, 6, 6]

2)要求在遍历数组 arr时，仍然可以以 **前序遍历**，**中序遍历**和**后序遍历**的方式完成结点的遍历

- **顺序存储二叉树的特点(重点):**

1. 顺序二叉树通常只考虑完全二叉树
2. 第n个元素的左子节点为  `2 * n + 1` 
3. 第n个元素的右子节点为  `2 * n + 2`
4. 第n个元素的父节点为  `(n-1) / 2`
5. n : 表示二叉树中的第几个元素(按0开始编号 如上图所示)

#### 10.1.13.2）顺序存储二叉树遍历实例

- 需求: 

  给你一个数组 *{*1,2,3,4,5,6,7}，要求以二叉树前序遍历的方式进行遍历。
  前中后序遍历的结果应当为：

  - 前序 1 2 4 5 3 6 7

  - 中序  4 2 5 1 6 3 
  - 后序 4 5 2 6 3 7 1

#### 10.1.13.3）顺序存储二叉树遍历实例-代码实现

```java
package com.wck.tree;

/**
 * 
 * @author YuXiangKaoChi
 * @createTime 2020-05-17 18:14:00
 * 	类说明：顺序存储二叉树遍历
 *  顺序二叉树通常只考虑完全二叉树
 */
public class ArrBinaryTreeDemo {

	public static void main(String[] args) {
		int[] arr = { 1, 2, 3, 4, 5, 6, 7 };
		ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr);
		//前序 1 2 4 5 3 6 7
		//arrBinaryTree.arrPrevOrder();
		//中序  4 2 5 1 6 3 7
		//arrBinaryTree.arrInfixOrder();
		//后序 4 5 2 6 3 7 1 
		arrBinaryTree.arrPostOrder();
	}
}

/**
 * 用数组来遍历前、中、后序
 * @author YuXiangKaoChi
 * @createTime 2020-05-17 18:15:13
 * 	类说明：
 * 顺序存储二叉树的特点:
   顺序二叉树通常只考虑完全二叉树
	第n个元素的左子节点为  2 * n + 1 
	第n个元素的右子节点为  2 * n + 2
	第n个元素的父节点为  (n-1) / 2
	n : 表示二叉树中的第几个元素(按0开始编号如图所示)

 */
class ArrBinaryTree{
	
	private int[] arr;
	
	public ArrBinaryTree(int[] arr) {
		//初始化数组
		this.arr=arr;
	}
	
	//前序遍历重载方法
	public void arrPrevOrder() {
		arrPrevOrder(0);
	}
	
	//中序遍历重载方法
	public void arrInfixOrder() {
		arrInfixOrder(0);
	}
	
	//后序遍历重载方法
	public void arrPostOrder() {
		arrPostOrder(0);
	}
	//前序遍历 根左右
	public void arrPrevOrder(int index) {
		//检查数组是否为空
		if(this.arr == null || this.arr.length == 0) {
			System.out.println("当前的数组为空，不能遍历");
		}
		//根
		System.out.println("前序遍历为："+arr[index]);
		//左
		if((2*index+1) < arr.length) {
			this.arrPrevOrder(2*index+1);
		}
		//右
		if((2 * index + 2) < arr.length) {
			this.arrPrevOrder(2*index+2);
		}
	}
	
	
	//中序遍历 左根右
	public void arrInfixOrder(int index) {
		//检查数组是否为空
		if (this.arr == null || this.arr.length == 0) {
			System.out.println("当前的数组为空，不能遍历");
		}
		// 左
		if ((2 * index + 1) < arr.length) {
			this.arrInfixOrder(2 * index + 1);
		}
		// 根
		System.out.println("中序遍历为：" + arr[index]);
		// 右
		if ((2 * index + 2) < arr.length) {
			this.arrInfixOrder(2 * index + 2);
		}
	}
	
	// 后序遍历 左右根
	public void arrPostOrder(int index) {
		// 检查数组是否为空
		if (this.arr == null || this.arr.length == 0) {
			System.out.println("当前的数组为空，不能遍历");
		}
		// 左
		if ((2 * index + 1) < arr.length) {
			this.arrPostOrder(2 * index + 1);
		}
		// 右
		if ((2 * index + 2) < arr.length) {
			this.arrInfixOrder(2 * index + 2);
		}
		// 根
		System.out.println("后序遍历为：" + arr[index]);
	}
}
```

### 10.1.14）线索化二叉树

- **先看一个问题**

将数列 {1, 3, 6, 8, 10, 14  } 构建成一颗二叉树.  n+1=7

<img src="images/78.png" alt="78" style="zoom:80%;" />

- 问题分析: 
  - 1)当我们对上面的二叉树进行中序遍历时，数列为 {8, 3, 10, 1, 14 ,6 }
  - 2)但是 6, 8, 10, 14 这几个节点的 左右指针，并没有完全的利用上.
  - 3)如果我们希望**充分的利用 各个节点的左右指针**， 让各个节点可以指向自己的前后节点,怎么办?
  - 4)解决方案-线索二叉树

#### 10.1.14.1）线索二叉树基本介绍

- 1)n个结点的二叉链表中含有n+1  【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向**该结点在某种遍历次序**下的前驱和后继结点的指针（这种附加的指针称为"线索"）
- 2)这种加上了线索的二叉链表称为**线索链表**，相应的二叉树称为**线索二叉树(ThreadedBinaryTree)**。根据线索性质的不同，线索二叉树可分为**前序线索二叉树、中序线索二叉树**和**后序线索二叉树**三种
- 3)一个结点的前一个结点，称为**前驱**结点
- 4)一个结点的后一个结点，称为**后继**结点

#### 10.1.14.2）线索二叉树应用案例

**应用案例说明**：将下面的二叉树，进行**中序线索二叉树**。中序遍历的数列为{8,3, 10, 1, 14, 6}

![78](images/78.png)

#### 10.1.14.3）线索二叉树应用案例-思路分析

**思路分析**:  [左根右]中序遍历的结果：{8,3, 10, 1, 14, 6}

![79](images/79.png)

**说明当线索化二叉树后，Node节点的 属性left 和right，有如下情况:**

1)left 指向的是左子树，也可能是指向的前驱节点. 比如 **① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点.**      

2)right指向的是右子树，也可能是指向后继节点，比如 **① 节点right 指向的是右子树，而⑩ 节点的right 指向的是后继节点.**

#### 10.1.14.4）线索二叉树应用案例-代码实现

```java
package com.wck.tree.threadedbinarytree;

/**
 * 
 * @author YuXiangKaoChi
 * @createTime 2020-05-18 10:46:12
 * 	类说明：线索化二叉树
 */
public class ThreadedBinaryTreeDemo {

	public static void main(String[] args) {
		// 测试一把中序线索二叉树的功能
		HeroNode root = new HeroNode(1, "tom");
		HeroNode node2 = new HeroNode(3, "jack");
		HeroNode node3 = new HeroNode(6, "smith");
		HeroNode node4 = new HeroNode(8, "mary");
		HeroNode node5 = new HeroNode(10, "king");
		HeroNode node6 = new HeroNode(14, "dim");

		// 二叉树，后面我们要递归创建, 现在简单处理使用手动创建
		root.setLeft(node2);
		root.setRight(node3);
		node2.setLeft(node4);
		node2.setRight(node5);
		node3.setLeft(node6);

		// 测试中序线索化
		ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree();
		threadedBinaryTree.setRoot(root);
		threadedBinaryTree.threadedNodes();

		// 测试: 以10号节点测试
		HeroNode leftNode = node5.getLeft();
		HeroNode rightNode = node5.getRight();
		System.out.println("10号结点的前驱结点是 =" + leftNode); // 3
		System.out.println("10号结点的后继结点是=" + rightNode); // 1
		
		//线索化二叉树遍历【中序】
		threadedBinaryTree.threadedList();
	}

}

class ThreadedBinaryTree {
	//需要传递的根节点
	private HeroNode root ;

	public void setRoot(HeroNode root) {
		this.root = root;
	}
	
	//为了实现线索化，需要创建要给指向当前结点的前驱节点指针
	//在递归进行线索化时，pre总是保留前一个节点
	private HeroNode pre;
	
	public void threadedNodes() {
		threadedNodes(this.root);
	}
	
	
	// 线索化二叉树遍历
	// 遍历线索化二叉树的方法
	public void threadedList() {
		// 定义一个变量，存储当前遍历的结点，从root开始
		HeroNode node = root;
		while (node != null) {
			// 循环的找到leftType == 1的结点，第一个找到就是8结点
			// 后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化
			// 处理后的有效结点
			while (node.getLeftType() == 0) {
				node = node.getLeft();
			}

			// 打印当前这个结点
			System.out.println(node);
			// 如果当前结点的右指针指向的是后继结点,就一直输出
			while (node.getRightType() == 1) {
				// 获取到当前结点的后继结点
				node = node.getRight();
				System.out.println(node);
			}
			// 替换这个遍历的结点
			node = node.getRight();

		}
	}
	
	/**
	 * 中序线索化 左根右
	 * 线索化方法，需要线索化的节点
	 * @param node
	 */
	public void threadedNodes(HeroNode node) {
		//线索化的节点为空，直接返回
		if(node == null) {
			return;
		}
		//一、线索化左
		threadedNodes(node.getLeft());
		
		//二、线索化根
		//处理当前结点的前驱结点
		//以8结点来理解
		//8结点的.left = null , 8结点的.leftType = 1
		if(node.getLeft() == null) {
			//让当前结点的左指针指向前驱结点 
			node.setLeft(pre);
			//修改当前结点的左指针的类型,指向前驱结点
			node.setLeftType(1);
		}
		//处理后继结点
		if(pre != null && pre.getRight() == null) {
			//让前驱结点的右指针指向当前结点
			pre.setRight(node);
			//修改前驱结点的右指针类型
			pre.setRightType(1);
		}
		//!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点
		pre=node;
		
		//三、线索化右
		threadedNodes(node.getRight());
		
	}
	
}
//英雄节点类
class HeroNode {
	// 英雄编号
	private int no;
	// 英雄姓名
	private String name;

	// 左边的节点
	private HeroNode left;
	// 右边的节点
	private HeroNode right;
	
	//左边节点的类型，0:子树 1：前驱节点
	private int leftType;
	//右边节点的类型，0:子树 1：后继节点
	private int rightType;

	public HeroNode(int no, String name) {
		this.no = no;
		this.name = name;
	}

	public int getNo() {
		return no;
	}

	public void setNo(int no) {
		this.no = no;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public HeroNode getLeft() {
		return left;
	}

	public void setLeft(HeroNode left) {
		this.left = left;
	}

	public HeroNode getRight() {
		return right;
	}

	public void setRight(HeroNode right) {
		this.right = right;
	}

	public int getLeftType() {
		return leftType;
	}

	public void setLeftType(int leftType) {
		this.leftType = leftType;
	}

	public int getRightType() {
		return rightType;
	}

	public void setRightType(int rightType) {
		this.rightType = rightType;
	}

	@Override
	public String toString() {
		return "HeroNode [no=" + no + ", name=" + name + "]";
	}
}
```

#### 10.1.14.5）遍历线索化二叉树

**说明：**对前面的中序线索化的二叉树， 进行遍历

**分析**：因为线索化后，各个结点指向有变化，因此，这时需要使用新的方式，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。 

#### 10.1.14.6）遍历线索化二叉树-代码实现

```java
package com.wck.tree.threadedbinarytree;

/**
 * 
 * @author YuXiangKaoChi
 * @createTime 2020-05-18 10:46:12
 * 	类说明：线索化二叉树
 */
public class ThreadedBinaryTreeDemo {

	public static void main(String[] args) {
		// 测试一把中序线索二叉树的功能
		HeroNode root = new HeroNode(1, "tom");
		HeroNode node2 = new HeroNode(3, "jack");
		HeroNode node3 = new HeroNode(6, "smith");
		HeroNode node4 = new HeroNode(8, "mary");
		HeroNode node5 = new HeroNode(10, "king");
		HeroNode node6 = new HeroNode(14, "dim");

		// 二叉树，后面我们要递归创建, 现在简单处理使用手动创建
		root.setLeft(node2);
		root.setRight(node3);
		node2.setLeft(node4);
		node2.setRight(node5);
		node3.setLeft(node6);

		// 测试中序线索化
		ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree();
		threadedBinaryTree.setRoot(root);
		threadedBinaryTree.threadedNodes();

		// 测试: 以10号节点测试
		HeroNode leftNode = node5.getLeft();
		HeroNode rightNode = node5.getRight();
		System.out.println("10号结点的前驱结点是 =" + leftNode); // 3
		System.out.println("10号结点的后继结点是=" + rightNode); // 1
		
		//线索化二叉树遍历【中序】
		threadedBinaryTree.threadedList();
	}

}

class ThreadedBinaryTree {
	//需要传递的根节点
	private HeroNode root ;

	public void setRoot(HeroNode root) {
		this.root = root;
	}
	
	//为了实现线索化，需要创建要给指向当前结点的前驱节点指针
	//在递归进行线索化时，pre总是保留前一个节点
	private HeroNode pre;
	
	public void threadedNodes() {
		threadedNodes(this.root);
	}
	
	
	// 线索化二叉树遍历
	// 遍历线索化二叉树的方法
	public void threadedList() {
		// 定义一个变量，存储当前遍历的结点，从root开始
		HeroNode node = root;
		while (node != null) {
			// 循环的找到leftType == 1的结点，第一个找到就是8结点
			// 后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化
			// 处理后的有效结点
			while (node.getLeftType() == 0) {
				node = node.getLeft();
			}

			// 打印当前这个结点
			System.out.println(node);
			// 如果当前结点的右指针指向的是后继结点,就一直输出
			while (node.getRightType() == 1) {
				// 获取到当前结点的后继结点
				node = node.getRight();
				System.out.println(node);
			}
			// 替换这个遍历的结点
			node = node.getRight();

		}
	}
	
	/**
	 * 中序线索化 左根右
	 * 线索化方法，需要线索化的节点
	 * @param node
	 */
	public void threadedNodes(HeroNode node) {
		//线索化的节点为空，直接返回
		if(node == null) {
			return;
		}
		//一、线索化左
		threadedNodes(node.getLeft());
		
		//二、线索化根
		//处理当前结点的前驱结点
		//以8结点来理解
		//8结点的.left = null , 8结点的.leftType = 1
		if(node.getLeft() == null) {
			//让当前结点的左指针指向前驱结点 
			node.setLeft(pre);
			//修改当前结点的左指针的类型,指向前驱结点
			node.setLeftType(1);
		}
		//处理后继结点
		if(pre != null && pre.getRight() == null) {
			//让前驱结点的右指针指向当前结点
			pre.setRight(node);
			//修改前驱结点的右指针类型
			pre.setRightType(1);
		}
		//!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点
		pre=node;
		
		//三、线索化右
		threadedNodes(node.getRight());	
	}	
}
//英雄节点类
class HeroNode {
	// 英雄编号
	private int no;
	// 英雄姓名
	private String name;

	// 左边的节点
	private HeroNode left;
	// 右边的节点
	private HeroNode right;
	
	//左边节点的类型，0:子树 1：前驱节点
	private int leftType;
	//右边节点的类型，0:子树 1：后继节点
	private int rightType;

	public HeroNode(int no, String name) {
		this.no = no;
		this.name = name;
	}

	public int getNo() {
		return no;
	}

	public void setNo(int no) {
		this.no = no;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public HeroNode getLeft() {
		return left;
	}

	public void setLeft(HeroNode left) {
		this.left = left;
	}

	public HeroNode getRight() {
		return right;
	}

	public void setRight(HeroNode right) {
		this.right = right;
	}

	public int getLeftType() {
		return leftType;
	}

	public void setLeftType(int leftType) {
		this.leftType = leftType;
	}

	public int getRightType() {
		return rightType;
	}

	public void setRightType(int rightType) {
		this.rightType = rightType;
	}

	@Override
	public String toString() {
		return "HeroNode [no=" + no + ", name=" + name + "]";
	}
}
```

#### 10.1.14.7）课后作业

我这里讲解了中序线索化二叉树，前序线索化二叉树和后序线索化二叉树的分析思路类似，同学们作为课后作业完成.

# 第十一章 树结构实际应用



## 11.1）堆排序

**基本介绍 ：**        

- 1)堆排序是利用**堆**这种数据结构而设计的一种排序算法，堆排序是一种**选择排序，**它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。
- 2)堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, **注意** : 没有要求结点的左孩子的值和右孩子的值的大小关系。
- 3)每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆
- 4)**一般升序采用大顶堆，降序采用小顶堆** 

> # 1. 什么是堆?
>
> 堆就是将一个集合的数据**按照完全二叉树的顺序结构存储在一个一维数组中**,堆在**逻辑**上是一棵**完全二叉树**,在**物理结构**上是一个一维**数组**.
>
> 按照根结点的大小分为**大堆**(根结点的值最大)和**小堆**(根结点的值最小)
>
> ## 1.1 堆的性质
>
> 性质:
>
> - 对于任意一个结点,都要求根的值 **大于或等于** 其所有子树结点的值
>
> - 堆是一棵完全二叉树
>
>   <img src="images/97.png" alt="97" style="zoom: 67%;" />

### 11.1.1）大顶堆举例说明

![80](images/80.png)

我们对堆中的结点按层进行编号，映射到数组中就是下面这个样子: 

![81](images/81.png)

大顶堆特点：`arr[i] >= arr[2*i+1] && arr[i] >= arr[2*i+2]`  // i 对应第几个节点，i从0开始编号

### 11.1.2）小顶堆举例说明

![82](images/82.png)

小顶堆特点：`arr[i] <= arr[2*i+1] && arr[i] <= arr[2*i+2]` // i 对应第几个节点，i从0开始编号

### 11.1.3）堆排序基本思想

堆排序的基本思想是：

1. 将待排序序列构造成一个大顶堆
2. 此时，整个序列的**最大值就是堆顶的根节点**。
3. 将其与**末尾元素进行交换，此时末尾就为最大值**。
4. 然后**将剩余n-1个元素重新构造成一个堆**，这样会**得到n个元素的次小值**。**如此反复执行，便能得到一个有序序列了。**

可以看到**在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了**.

### 11.1.4）堆排序步骤图解说明

要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。

**步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。**  

1) .假设给定无序序列结构如下      

<img src="images/83.png" alt="83" style="zoom: 33%;" />

2) .此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 `arr.length/2-1=5/2-1=1`，**也就是下面的6结点），从左至右，从下至上进行调整。**

<img src="images/84.png" alt="84" style="zoom: 33%;" />

3) .找到第二个非叶节点4，由于\[4,9,8\]中9元素最大，4和9交换。

<img src="images/85.png" alt="84" style="zoom: 33%;" />

4) 这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。

<img src="images/86.png" alt="86" style="zoom:33%;" />

此时，我们就将一个无序序列构造成了一个大顶堆。    

**步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。**

1) .将堆顶元素9和末尾元素4进行交换

<img src="images/87.png" alt="87" style="zoom:33%;" />

2) .重新调整结构，使其继续满足堆定义

<img src="images/88.png" alt="88" style="zoom:33%;" />

3) .再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.

<img src="images/89.png" alt="89" style="zoom:33%;" />

4) 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序

<img src="images/90.png" alt="90" style="zoom:33%;" />

**再简单总结下堆排序的基本思路：**  

- **1).将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;**

- **2).将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;**

- **3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。**

### 11.1.5）堆排序代码实现

要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序(从小到大)。

说明：堆排序的**速度非常快**，在我的机器上 8百万数据 3 秒左右。O(nlogn) 

```java
package com.wck.tree;

import java.util.Arrays;

/**
 * 
 * @author YuXiangKaoChi
 * @createTime 2020-05-19 20:25:39
 * 类说明：堆排序（重点比较难理解）
 */
public class HeapSortDemo {

	//堆排序测试
	public static void main(String[] args) {
//		int arr[] = { 4, 6, 8, 5, 9 };
//		heapSort(arr);
		
		int[] arr=new int[8000000];
		for (int i = 0; i < 8000000; i++) {
			arr[i]=(int)(Math.random()*800000000);
		}
		System.out.println("排序前的时间：");
		long currentTimeMillis = System.currentTimeMillis();
		System.out.println(currentTimeMillis);
		heapSort(arr);
		System.out.println("排序后的时间：");
		System.out.println(System.currentTimeMillis()-currentTimeMillis);
		
//		排序前的时间：
//		1589895484721
//		排序后的时间：
//		1617
	}
	
	/**
	 * 堆排序
	 * @param arr 传入待排序的数组
	 */
	public static void heapSort(int[] arr) {	
		/*
		//第一次大顶堆排序
		adjustHeap(arr,1,arr.length);
		System.out.println(Arrays.toString(arr));
		//第二次大顶堆排序
		adjustHeap(arr,0,arr.length);
		System.out.println(Arrays.toString(arr));
		*/
		int temp=0;//用于交换缓存值
		//通过遍历，处理非叶子节点的树，为大顶堆
		for(int i=arr.length/2-1;i>=0;i--) {
			adjustHeap(arr,i,arr.length);
		}
//		System.out.println(Arrays.toString(arr));
		//将堆顶元素与末尾元素进行交换，使末尾元素最大
		//[9, 6, 8, 5, 4]
		for(int j=arr.length-1;j>0;j--) {
			temp=arr[j];//缓存最小的值
			arr[j]=arr[0];//交换值
			arr[0]=temp;//交换值
			adjustHeap(arr, 0, j);
		}
//		System.out.println("数组=" + Arrays.toString(arr)); 
		
	}
	/**
	 * 将传入的数组，以 i 为根节点的树，进行大顶堆的排序
	 * @param arr 数组
	 * @param i  要排序的i(索引)为根节点
	 * @param length 需要排序的长度
	 */
	public static void adjustHeap(int[] arr, int i, int length) {
		int temp = arr[i];// 将要比较的这个根节点缓存起来
		// 从第一个非叶子节点开始进行，大顶堆得排序
		for (int k = i*2 + 1; k <length; k = k*2 + 1) {
			// 查找所有的节点，找到最大的那一个的下标
			if (k+1 < length && arr[k] < arr[k + 1]) {
				k++;
			}
			// 下面的左右节点有一个比根节点大，则需要进行交换
			if (arr[k] > temp) {
				arr[i] = arr[k];// 交换
				i = k;// 交换完成后，i所指向的为k 这个索引
			} else {
				// 如果不大于，则直接进行跳出返回
				break;
			}
		}

		// 到这一步，说明最大的顶堆已经找到，则需要把缓存的值，赋值给索引为i的值
		arr[i] = temp;
	}
}
```

## 11.2）赫夫曼树

### 11.2.1）基本介绍

- 1)给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为**最优二叉树**，也称为**哈夫曼树(Huffman Tree)**, 还有的书翻译为**霍夫曼树**。

- 2)赫夫曼树是**带权路径长度最短的树，权值较大的结点离根较近**。

### 11.2.2）赫夫曼树几个重要概念和举例说明

1)路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。**若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1**      

2)**结点的权及带权路径长度：**若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。**结点的带权路径长度**为：从根结点到该结点之间的路径长度与该结点的权的乘积

<img src="images/91.png" alt="91" style="zoom: 50%;" />

3)**树的带权路径长度：**树的带权路径长度规定为所有**叶子结点**的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。

4)**WPL最小的就是赫夫曼树**

<img src="images/92.png" alt="92" style="zoom:80%;" />

### 11.2.3）赫夫曼树创建思路图解

给你一个数列 {13, 7, 8, 3, 29, 6, 1}，要求转成一颗赫夫曼树.

{13, 7, 8, 3, 20, 6, 1}  

构成赫夫曼树的步骤

1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树.

2) 取出根节点权值最小的两颗二叉树 

3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和  

4)  再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复  1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树

<img src="images/93.png" alt="93" style="zoom:67%;" />

### 11.2.4）赫夫曼树的代码实现

```java
package com.wck.tree;

import java.util.ArrayList;
import java.util.Collections;

public class HuffmanTree {

	public static void main(String[] args) {
		
		int[] arr= {13, 7, 8, 3, 29, 6, 1};
		Node tree = createHuffmanTree(arr);
		prevOrder(tree);
	}
	
	public static void prevOrder(Node root) {
		root.prevOrder();
	}
	
	//创建哈夫曼树
	public static Node createHuffmanTree(int[] arr) {
		//将传入的数组，转换成树节点
		ArrayList<Node> nodes = new ArrayList<Node>();
		for(int value:arr) {
			nodes.add(new Node(value));
		}
//		int count=0;
		while (nodes.size() >1) {
//			System.out.println("排序前："+nodes);
			Collections.sort(nodes);
//			System.out.println("排序后："+nodes);

			//获取第一个最小的值，当做左结点
			Node leftNode=nodes.get(0);
			//获取第二个最小的值，当做右结点
			Node rightNode=nodes.get(1);
			//创建父节点，结点的值为 左右节点的和
			Node parentNode=new Node(leftNode.value+rightNode.value);
			//设置左结点
			parentNode.left=leftNode;
			//设置右结点
			parentNode.right=rightNode;
			
			//去掉刚刚组合的左右结点
			nodes.remove(leftNode);//左节点
			nodes.remove(rightNode);//右节点
			
			//把新的父节点加入到结点列表中去
			nodes.add(parentNode);
			
//			System.out.println("第"+(++count)+"次选取后："+nodes);
		}
		//返回最后调整完的结点
		return nodes.get(0);
		
	}
}
//树节点
class Node implements Comparable<Node>{
	//结点的值，权
	int value;
	//左侧的结点
	Node left;
	//右侧的结点
	Node right;
	public Node(int value) {
		this.value=value;
	}	
	//前序遍历,根左右
	public void prevOrder() {
		//根
		System.out.print(this.value + "  ");
		//左
		if(this.left != null) {
			this.left.prevOrder();
		}
		//右
		if(this.right != null) {
			this.right.prevOrder();
		}
	}
	@Override
	public int compareTo(Node node) {
		//升序
		return this.value - node.value;
	}
	@Override
	public String toString() {
		return "Node [value=" + value + "]";
	}
}
```



## 11.3）赫夫曼编码

### 11.3.1）基本介绍

1)赫夫曼编码也翻译为    **哈夫曼**编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法

2)赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。

3)赫夫曼编码广泛地用于数据文件压缩。其**压缩率通常在20%～90%**之间

4)赫夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码

### 11.3.2）原理剖析

- 1）通信领域中信息的处理方式1-定长编码
  - `i like like like java do you like a java`       // 共40个字符(包括空格)  
  - `105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97`  //对应Ascii码
  - `01101001 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101010 01100001 01110110 01100001 00100000 01100100 01101111 00100000 01111001 01101111 01110101 00100000 01101100 01101001 01101011 01100101 00100000 01100001 00100000 01101010 01100001 01110110 01100001` //对应的二进制
  - •按照二进制来传递信息，总的长度是  359   (包括空格)
  - 在线转码 工具 ：https://www.mokuge.com/tool/asciito16/ 

- 2）通信领域中信息的处理方式2-变长编码
  - `i like like like java do you like a java`// 共40个字符(包括空格)
  - `d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9`  // 各个字符对应的个数
  - `0=  ,  1=a, 10=i, 11=e, 100=k, 101=l, 110=o, 111=v, 1000=j, 1001=u, 1010=y, 1011=d`说明：按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如 空格出现了9 次， 编码为0 ,其它依次类推.
  - 按照上面给各个字符规定的编码，则我们在传输  `"i like like like java do you like a java"` 数据时，编码就是 `10010110100...`  
  - 字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码， 即不能匹配到重复的编码(这个在赫夫曼编码中，我们还要进行举例说明)

- 3）通信领域中信息的处理方式3-赫夫曼编码
  - `i like like like java do you like a java`   // 共40个字符(包括空格)
  - `d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9`  // 各个字符对应的个数
  - 按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值.(图后)

![94](images/94.png)

- **特别注意**, 这个赫夫曼树根据排序方法不同，也可能不太一样，**这样对应的赫夫曼编码也不完全一样**，但是wpl 是一样的，都是最小的, 比如: 如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树为:

![95](images/95.png)



### 11.3.3）最佳实践-数据压缩(创建赫夫曼树)

- 将给出的一段文本，比如 `"i like like like java do you like a java"` ， 根据前面的讲的赫夫曼编码原理，对其进行数据压缩处理 ，**形式**如 `1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110` 

1)我们已经生成了 赫夫曼树

2)生成赫夫曼树对应的赫夫曼编码  , 如下表:
 `=01 a=100 d=11000 u=11001 e=1110 v=11011 i=101 y=11010 j=0010 k=1111 l=000 o=0011`

3)用赫夫曼编码来生成赫夫曼编码数据 ,即按照上面的赫夫曼编码，将`"i like like like java do you like a java"`   字符串生成对应的编码数据, 形式如下.
 `1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100`

### 11.3.4）最佳实践-数据压缩-代码实现

![96](images/96.png)

功能： 根据赫夫曼编码压缩数据的原理，需要创建 `"i like like like java do you like a java"` 对应的赫夫曼树

思路:

- (1) `Node { data (存放数据)， weight (权值)， left  和 right }`
- (2) 得到  "`i like like like java do you like a java`"   对应的 byte[] 数组
- (3)  编写一个方法，将准备构建赫夫曼树的Node 节点放到 List  , 形式 `[Node[date=97 ,weight = 5], Node[date=32,weight = 9]......]`,  体现 `d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9`  
- (4) 可以通过List 创建对应的赫夫曼树

### 11.3.5）最佳实践-文件压缩

我们学习了通过赫夫曼编码对一个字符串进行编码和解码, 下面我们来完成对文件的压缩和解压， 具体要求：给你一个图片文件，要求对其进行无损压缩, 看看压缩效果如何。

**思路**：读取文件-> 得到赫夫曼编码表 -> 完成压缩

### 11.3.6）哈夫曼章节的最终代码实现

**代码实现：**

```java
package com.wck.huffmancode;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
public class HuffmanCode {
	
	public static void main(String[] args) {
		/*
		//封装方法后的调用
		//将要转换的字符串
		String content="i like like like java do you like a java";
		byte[] b = content.getBytes();
		byte[] huffmanZip = huffmanZip(b);
		System.out.println("~压缩编码后的字节数组为："+Arrays.toString(huffmanZip)+",长度为："+huffmanZip.length);
		*/
		
		/*
		String content="i like like like java do you like a java";
		 //分步骤 写法
		 //获取字节数组
		byte[] bytes=content.getBytes();
		
		//获取字节数组对应的节点列表
		List<Node> nodes = getNodes(bytes);
//		System.out.println("---------------1---------------");
//		System.out.println(nodes);
		//创建哈夫曼树
		Node rootNode = createHuffmanTree(nodes);
//		System.out.println("---------------2---------------");
//		System.out.println("根节点："+rootNode);
//		System.out.println("前序遍历为：");
		//preOrder(rootNode);
		System.out.println("---------------3---------------");
		System.out.println("哈夫曼编码后：");
		Map<Byte, String> codes = getCodes(rootNode);
		System.out.println(codes);
		byte[] zip = zip(bytes,codes);
		System.out.println("压缩编码后的字节数组为："+Arrays.toString(zip)+",长度为："+zip.length);
		//{32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011}
		//压缩编码后的字节数组为：[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28],长度为：17
		decode(codes,zip);
		*/
		
		//测试压缩文件
//		String srcFile = "D:\\wallhaven\\BBYyxAf.gif";
//		String dstFile = "D:\\wallhaven\\ceshi.zip";
//		
//		zipFile(srcFile, dstFile);
//		System.out.println("压缩文件ok~~");
		//测试解压文件
		String zipFile = "D:\\wallhaven\\ceshi.zip";
		String dstFile = "D:\\wallhaven\\hahahahahahah.gif";
		unZipFile(zipFile, dstFile);
		System.out.println("解压成功!");
		
	}
	//编写一个方法，完成对压缩文件的解压
	/**
	 * 
	 * @param zipFile 准备解压的文件
	 * @param dstFile 将文件解压到哪个路径
	 */
	public static void unZipFile(String zipFile, String dstFile) {
		
		//定义文件输入流
		InputStream is = null;
		//定义一个对象输入流
		ObjectInputStream ois = null;
		//定义文件的输出流
		OutputStream os = null;
		try {
			//创建文件输入流
			is = new FileInputStream(zipFile);
			//创建一个和  is关联的对象输入流
			ois = new ObjectInputStream(is);
			//读取byte数组  huffmanBytes
			byte[] huffmanBytes = (byte[])ois.readObject();
			//读取赫夫曼编码表
			Map<Byte,String> huffmanCodes = (Map<Byte,String>)ois.readObject();		
			//解码
			byte[] bytes = decode(huffmanCodes, huffmanBytes);
			//将bytes 数组写入到目标文件
			os = new FileOutputStream(dstFile);
			//写数据到 dstFile 文件
			os.write(bytes);
		} catch (Exception e) {
			// TODO: handle exception
			System.out.println(e.getMessage());
		} finally {			
			try {
				os.close();
				ois.close();
				is.close();
			} catch (Exception e2) {
				// TODO: handle exception
				System.out.println(e2.getMessage());
			}
		}
	}
	
	//编写方法，将一个文件进行压缩
	/**
	 * 
	 * @param srcFile 你传入的希望压缩的文件的全路径
	 * @param dstFile 我们压缩后将压缩文件放到哪个目录
	 */
	public static void zipFile(String srcFile, String dstFile) {
		//创建输出流
		OutputStream os = null;
		ObjectOutputStream oos = null;
		//创建文件的输入流
		FileInputStream is = null;
		try {
			//创建文件的输入流
			is = new FileInputStream(srcFile);
			//创建一个和源文件大小一样的byte[]
			byte[] b = new byte[is.available()];
			//读取文件
			is.read(b);
			//直接对源文件压缩
			byte[] huffmanBytes = huffmanZip(b);
			//创建文件的输出流, 存放压缩文件
			os = new FileOutputStream(dstFile);
			//创建一个和文件输出流关联的ObjectOutputStream
			oos = new ObjectOutputStream(os);
			//把 赫夫曼编码后的字节数组写入压缩文件
			oos.writeObject(huffmanBytes); //我们是把
			//这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用
			//注意一定要把赫夫曼编码 写入压缩文件
			oos.writeObject(huffmanMapCode);	
		}catch (Exception e) {
			// TODO: handle exception
			System.out.println(e.getMessage());
		}finally {
			try {
				is.close();
				oos.close();
				os.close();
			}catch (Exception e) {
				// TODO: handle exception
				System.out.println(e.getMessage());
			}
		}
		
	}
	/**
	 * 对哈夫曼编码后的字节数组进行解码
	 * @param huffmanCodes 哈夫曼编码Map 如：
	 * 		{32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011}
	 * @param huffmanBytes 哈夫曼编码后的字节数组 如：
	 * 		[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]
	 */
	public static byte[] decode(Map<Byte, String> huffmanCodes,byte[] huffmanBytes) {
		
		//1.首先先把 huffmanBytes 数组中的值，先转换成 二进制 字符串
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < huffmanBytes.length; i++) {
			if(i == huffmanBytes.length-1) {//表明这个是哈夫曼编码数组中的最后一个索引的值
				stringBuilder.append(byteToBitString(false, huffmanBytes[i]));
			}else {
				//不是哈夫曼编码数组中的最后一个索引值得情况
				stringBuilder.append(byteToBitString(true, huffmanBytes[i]));
			}
		}
//		System.out.println();
//		System.out.println("-----------------解码--------------------");
//		System.out.println("解码：哈夫曼编码数组转换的二进制串为："+stringBuilder.toString());
		
		//2.通过哈夫曼编码的值，找出对应的byte字节
		//2.1 需要反转当前的 huffmanCodes key 和value 
		Map<String, Byte> reverseHuffmanCodes=new HashMap<String, Byte>();
		for (Entry<Byte, String> h:huffmanCodes.entrySet()) {
			//互相反转得到 新的Map
			reverseHuffmanCodes.put(h.getValue(), h.getKey());
		}
		//3 通过反转后的Map 查找和解码的字符串对用关系，找到byte字节，解出哈夫曼编码
		List<Byte> listBytes=new ArrayList<Byte>();
		for (int i = 0; i < stringBuilder.length();) {
			int count =1;//查找计数器
			while(true) {
				String searchKey = stringBuilder.substring(i, i+count).toString();
				//System.out.println("searchKey:"+searchKey);
				//获取查找的key
				Byte b = reverseHuffmanCodes.get(searchKey);
				if(b == null ) {//表示在Map中没有找到对应得字节
					count++;
				}else {
					listBytes.add(b);
					break;
				}
			}
			i+=count;
		}
//		System.out.println("获取到的字节数组结果为：");
//		System.out.println(listBytes);
		
		//此时到这里就获取到了解码后的所有内容
		byte[] decodeByte=new byte[listBytes.size()];
		for (int i = 0; i < listBytes.size(); i++) {
			decodeByte[i]=listBytes.get(i);
		
//		System.out.println(Arrays.toString(decodeByte));
//		System.out.println(new String(decodeByte));
		//返回获取到的内容
		return decodeByte;
	} 
	/**
	 * 把传入进来的 字节转换成8位的二进制
	 * @param flag 判断是否是字节数组的最后的一个数组元素
	 * 				因为最后一个数组元素，可能不满足8位
	 * 				true:代表 不是最后一位
	 * 				false:代表是最后一位
	 * @param b 字节的值
	 * @return
	 */
	public static String byteToBitString(boolean flag,byte b) {
		//先临时把字节转换为 int ,这样目的是为了：可以使用 Integer.toBinaryString这个转换二进制的方法
		int temp=b;	
		//不是字节数组，最后一位索引值得情况
		if(flag) {//当不是字节数组的最后一个元素的时候，需要处理补位的情况
			//如果为负数则不需要补位
			//如果值为整数则需要补位
			temp=temp|256;
		}
		String str=Integer.toBinaryString(temp);
		if(flag) {
			//返回截取的后八位二进制的值
			return str.substring(str.length()-8);
		}else {
			//字节数组最后一个索引的值，直接返回
			return str;
		}
	}
	/**
	 * 将待压缩字符串压缩为字节数组
	 * @param content
	 * @return
	 */
	public static byte[] huffmanZip(byte[] bytes) {
		//1 获取字节数组对应的节点列表，使之为带有数据和权重以及左右孩子的列表
		List<Node> nodes = getNodes(bytes);
		//2 创建哈夫曼树
		Node rootNode = createHuffmanTree(nodes);
		//3 获得赫夫曼树的哈夫曼编码
		Map<Byte, String> codes = getCodes(rootNode);
		System.out.println("~获得的哈夫曼编码为："+codes);
		//对获得的哈夫曼编码进行压缩成 字节数组
		byte[] zip = zip(bytes,codes);
		
		return zip;
		
	}
	
	/**
	 * 把哈夫曼编码压缩,返回字节码数组
	 * @param bytes 原始的字节码数组
	 * @param huffmanCodes  哈夫曼编码后的Map
	 * @return
	 */
	public static byte[] zip(byte[] bytes ,Map<Byte, String> huffmanCodes) {
		
		//将bytes中的字节，转成huffmanCode字符串
		StringBuilder stringBuilder=new StringBuilder();
		//遍历 bytes 字节数组，拿到哈夫曼编码中的编码串
		for (byte b : bytes) {
			stringBuilder.append(huffmanCodes.get(b));
		}
		
		System.out.println("~得到的哈夫曼编码串为："+stringBuilder.toString());
		//得到的哈夫曼编码串为：1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100
		//把得到的哈夫曼编码的字符串，转成字节数组 每8个 为 1组
		
		//字符串的长度
		int len;
		if(stringBuilder.length() % 8 == 0) {//刚好是8的整数倍
			len=stringBuilder.length()/8;
		}else {//不是8的整数倍
			len=stringBuilder.length()/8+1;
		}
		
		//压缩后的哈夫曼编码的字节数组
		byte[] huffmanCodeBytes=new byte[len];
		int index =0;//索引标记
		//遍历得到的哈夫曼编码的字符串
		for (int i = 0; i < stringBuilder.length(); i+=8) {
			String strByte;
			if(i+8 > stringBuilder.length()) {//不满足 8位
				strByte=stringBuilder.substring(i);
			}else {
				strByte=stringBuilder.substring(i,i+8);
			}
//			System.out.println("strByte:"+strByte);
//			System.out.println("Integer:"+Integer.parseInt(strByte, 2));
//			System.out.println("byte:"+(byte)Integer.parseInt(strByte, 2));
			huffmanCodeBytes[index] = (byte)Integer.parseInt(strByte, 2);
			index++;
		}
		
		return huffmanCodeBytes;
	}
	//重载获取哈夫曼编码的方法
	public static Map<Byte, String> getCodes(Node rootNode){
		if(rootNode == null) {
			System.out.println("传递的根节点为空");
			return null;
		}
		//左边的节点
		getCodes(rootNode.left,"0",stringBuilder);
		//右边的节点
		getCodes(rootNode.right,"1",stringBuilder);
		//前序遍历
		//preOrder(rootNode);	
		return huffmanMapCode;
	}
	//HashMap存放找到的哈夫曼编码 key存放值，value存放编码
	static Map<Byte, String> huffmanMapCode=new HashMap<Byte, String>();
	
	//用于存放找到的路径编码
	static StringBuilder stringBuilder = new StringBuilder();
	
	/**
	 * 用于获取哈夫曼编码
	 * @param node  当前的节点
	 * @param code 左右分支 左边 传递 0  右边 传递 1
	 * @param stringBuilder 用于拼接哈夫曼编码的路径编码值
	 */
	public static void getCodes(Node node,String code,StringBuilder stringBuilder) {
		
		StringBuilder stringBuilder2=new StringBuilder(stringBuilder);
		stringBuilder2.append(code);
		if(node != null) {//当传递的不是叶子结点的时候
			if(node.data == null) {
				if(node.left != null) {//左分支节点
					getCodes(node.left, "0", stringBuilder2);
				}
				
				if(node.right != null) {//右分支节点不为空
					getCodes(node.right, "1", stringBuilder2);
				}
			}else {//说明已经到了叶子结点，可以返回
				huffmanMapCode.put(node.data, stringBuilder2.toString());
			}
		}
	}
	//前序遍历
	public static void preOrder(Node rootNode) {
		rootNode.preOrder();
	}
	//创建哈夫曼树
	public static Node createHuffmanTree(List<Node> nodes) {
		//当列表中的元素大于1的时候，遍历
		while (nodes.size() >1) {
			Collections.sort(nodes);	
			//取出左子节点
			Node leftNode=nodes.get(0);
			//取出右子节点
			Node rightNode=nodes.get(1);
			//创建一个父节点
			Node parent = new Node(null, leftNode.weight+rightNode.weight);
			//把左右子节点分别挂上
			parent.left=leftNode;//左节点
			parent.right=rightNode;//右节点		
			nodes.remove(leftNode);//移除左节点
			nodes.remove(rightNode);//移除右节点
			nodes.add(parent);//加入刚刚组合的根节点
		}
		//返回根节点
		return nodes.get(0);
		
	}	
	//获取节点
	public static List<Node> getNodes(byte[] bytes) {
		//待返回的节点列表
		List<Node> nodes=new ArrayList<Node>();
		//需要统计的节点次数
		Map<Byte, Integer> counts = new HashMap<Byte, Integer>();
		
		for(Byte b:bytes) {
			Integer count = counts.get(b);//获取次数
			if(count == null) {//说明没有统计过
				counts.put(b, 1);//加入进去到map中
			}else {
				counts.put(b, count+1);//把当前的字符统计数加一
			}
		}
		
		//创建Nodes列表
		for(Entry<Byte, Integer> entry:counts.entrySet()) {
			nodes.add(new Node(entry.getKey(), entry.getValue()));
		}
		//返回节点列表
		return nodes;
		
	}
}

//树节点类
class Node implements Comparable<Node>{
	
	//存放数据
	Byte data;
	
	//存放权重，也即是次数
	int weight;
	
	//左子节点
	Node left;
	//右子节点
	Node right;
	
	//前序遍历
	public void preOrder() {
		//根
		System.out.println(this);
		//左
		if(this.left != null) {
			this.left.preOrder();
		}
		//右
		if(this.right != null) {
			this.right.preOrder();
		}
	}
	
	public Node(Byte data, int weight) {
		this.data = data;
		this.weight = weight;
	}
	@Override
	public String toString() {
		return "Node [data=" + data + ", weight=" + weight + "]";
	}
	@Override
	public int compareTo(Node o) {
		//从小到大进行排序
		return this.weight-o.weight;
	}	
}
```



















