# 第一章 内容介绍

## 1.1）数据结构和算法内容介绍

### 1.1.1）先看几个经典的算法面试题

#### ①字符串匹配问题

有一个字符串 str1= ""你好世界  你好是吉恩世界 你好是世界""，和一个子串 str2="你好是世界"      

现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1         

要求用最快的速度来完成匹配     

你的思路是什么？     

- 暴力匹配【简单但是效率低下】
- **KMP算法《部分匹配表》**

#### ②汉诺塔游戏问题

汉诺塔游戏, 请完成汉诺塔游戏的代码: 

要求：

- 1) 将A塔的所有圆盘移动到C塔。并且规定，
- 2) 在小圆盘上不能放大圆盘，
- 3)在三根柱子之间一次只能移动一个圆盘

![1](images/1.png)

#### ③八皇后问题

八皇后问题  

是一个古老而著名的问题，是回溯算法的典型案例。

该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：

在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，

即：**任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法**。【92】=>**分治算法**

**使用到回溯算法**
高斯认为有76种方案。

1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，**后来有人用图论的方法解出92种结果**。计算机发明后，有多种计算机语言可以解决此问题。【小游戏链接：http://www.7k7k.com/swf/49842.htm】

<img src="images/2.png" alt="2" style="zoom: 67%;" />

#### ④马踏棋盘问题

马踏棋盘算法介绍和游戏演示    
马踏棋盘算法也被称为骑士周游问题  
**将马随机放在国际象棋的8×8棋盘Board\[0～7][0～7]的某个方格中，马按走棋规则(马走日字)进行移动**。    

要求每个方格只进入一次，**走遍棋盘上全部64个方格**     

**会使用到图的深度优化遍历算法(DFS) + 贪心算法优化**

小游戏链接演示: http://www.4399.com/flash/146267_2.htm 

<img src="images/3.png" alt="3" style="zoom:67%;" />

### 1.1.2）数据结构和算法的重要性

- **1）算法是程序的灵魂，优秀的程序可以在海量数据计算时，依然保持高速计算**
- 2）一般来讲 **程序会使用了内存计算框架(比如Spark)和缓存技术(比如Redis等)来优化程序**,再深入的思考一下，这些计算框架和缓存技术， 它的核心功能是哪个部分呢？
- **3）如果你不想永远都是代码工人,那就花时间来研究下数据结构和算法**

# 第二章 数据结构和算法概述

## 2.1）数据结构和算法的关系

- 数据data结构(structure)是一门**研究组织数据**方式的学科，有了编程语言也就有了数据结构.学好数据结构可以编写出更加漂亮,更加有效率的代码。
- 要学习好数据结构就要多多考虑如何将生活中遇到的问题,用程序去实现解决.
- **程序 = 数据结构 + 算法**
- 数据结构是算法的基础, 换言之，想要学好算法，需要把**数据结构学到位**。

## 2.2）看几个实际编程中遇到的问题

### 2.2.1）问题一，字符串替换问题

```java

Java代码:
	 public static void main(String[] args) {
		String str = "Java,Java, hello,world!";
		String newStr = str.replaceAll("Java", "wck~"); //算法
		System.out.println("newStr=" + newStr);
	}
```

问：         

试写出用单链表表示的字符串类及字符串结点类的定义，并依次实现它的构造函数、以及计算串长度、串赋值、判断两串相等、求子串、两串连接、求子串在串中位置等7个成员函数。    

小结：需要使用到**单链表数据结构**

### 2.2.2）问题二，一个五子棋程序

![4](images/4.png)

问：如何判断游戏的输赢，并可以完成存盘退出和继续上局的功能      

- 棋盘=>**二维数组**=>(**稀疏数组)**-> 写入文件  【存档功能】 

-   读取文件-》稀疏数组-》二维数组 -》 棋盘 【接上局】   

  

小结：需要用到**二维数组，稀疏数组**

### 2.2.3）问题三，约瑟夫(Josephu)问题(丢手帕问题)

![5](images/5.png)

- 1）Josephu  问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1<=k<=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。
- 2）提示：用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表（单向环形链表），然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束

小结：需要用到**单向环形链表**

### 2.2.4）其它常见算法问题

![6](images/6.png)

- 1）**修路问题  => 最小生成树(加权值)【数据结构】+ 普利姆算法**
- 2）**最短路径问题  => 图+弗洛伊德算法**
- 3）**汉诺塔 => 分支算法** 
- 4）**八皇后问题 => 回溯法**

## 2.3）线性结构和非线性结构

数据结构包括：**线性**结构和**非线性**结构。    

### 2.3.1）线性结构

- 1）线性结构作为最常用的数据结构，其特点是**数据元素之间存在一对一的线性关系**
- 2）线性结构有两种不同的存储结构，即**顺序存储结构和链式存储结构**。**顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的**
- 3）链式存储的线性表称为链表，链表中的**存储元素不一定是连续**的，**元素节点中存放数据元素以及相邻元素的地址信息**
- 4）线性结构常见的有：**数组、队列、链表和栈**

### 2.3.2）非线性结构

- 非线性结构包括：**二维数组，多维数组，广义表，树结构，图结构**

# 第三章 稀疏数组和队列

## 3.1）稀疏sparsearray数组

### 3.1.1）先看一个实际的需求

- 编写的五子棋程序中，有存盘退出和续上盘的功能。

<img src="images/7.png" alt="7" style="zoom:67%;" />

- 分析问题: 
  因为该二维数组的很多值是默认值0, 因此记录了**很多没有意义的数据-**>**稀疏数组**

### 3.1.2）基本介绍

**当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。**

稀疏数组的处理方法是:

- 记录数组**一共有几行几列，有多少个不同的值**
- 把**具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模**



稀疏数组的举例：

<img src="images/8.png" alt="8" style="zoom:80%;" />

### 3.1.3）应用实例

- 使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)
- 把稀疏数组存盘，并且可以从新恢复原来的二维数组数
- 整体思路分析

![9](images/9.png)

思路：

- 二维数组 转 稀疏数组的思路
  - 1）遍历原始的二维数组，**得到有效的数据个数sum**
  - 2）根据sum就可以**创建稀疏数组 sparseArr int\[sum+1\]\[3\]**
  - 3）将二维数组的**有效数据存入到稀疏数组**

- 稀疏数组转原始的二维数组的思路
  - 1）**先读取稀疏数组的第一行**，根据第一行的数据，**创建原始的二维数组**，比如上面的chessArr2=int \[11\]\[11\]
  - 2）**再读取**稀疏数组**后几行的数据**，并**赋值给原始的二维数据即可**



### 3.1.4）代码实现

```java
package com.wck.sparsearray;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
/*
 *稀疏数组，棋盘问题 
 并写入到磁盘中文件中和读取磁盘文件
 将稀疏数组保存到磁盘上，比如 map.data
 恢复原来的数组时，读取map.data 进行恢复
 */
public class SparseArray {
	public static void main(String[] args) throws IOException {
		// 创建一个二维数组 11 * 11
		// 0:没有棋子 1：表示 黑子 2：表示蓝子
		int[][] chessArray = new int[11][11];
		chessArray[1][2] = 1;// 黑子
		chessArray[2][3] = 2;// 蓝子
//		chessArray[2][4]=2;//蓝子
		// 输出原始的二维数组
//		System.out.println(Arrays.deepToString(chessArray));
		System.out.println("原始二维数组：");
		printArray(chessArray);// 打印二维数组
		// 二维数组 转 稀疏数组
		/**
		 * 
		 * - 1）遍历原始的二维数组，**得到有效的数据个数sum** 
		 * - 2）根据sum就可以**创建稀疏数组 sparseArr
		 * int\[sum+1\]\[3\]** - 3）将二维数组的**有效数据存入到稀疏数组**
		 */
		// 统计有效数据的个数
		int sum = 0;
		// 行数
		int row = chessArray.length;
		// System.out.println("行数："+row);
		int col = chessArray[0].length;
		// System.out.println("列数："+col);
		for (int i = 0; i < chessArray.length; i++) {
			for (int j = 0; j < chessArray[i].length; j++) {
				if (chessArray[i][j] != 0) {
					// System.out.println(chessArray[i][j]);
					sum++;// 统计计算有效的数值个数
				}
			}
		}
		System.out.println("有效数字总数sum:" + sum);
		int[][] chessArr1 = new int[sum + 1][3];
		chessArr1[0][0] = row;// 行
		chessArr1[0][1] = col;// 列
		chessArr1[0][2] = sum;// 有效个数
		int count = 0;
		for (int i = 0; i < chessArray.length; i++) {
			for (int j = 0; j < chessArray[i].length; j++) {
				if (chessArray[i][j] != 0) {
					count++;
					chessArr1[count][0] = i;
					chessArr1[count][1] = j;
					chessArr1[count][2] = chessArray[i][j];
				}
			}
		}
		System.out.println("稀疏二维数组：");
		 printArray(chessArr1);
		writerArray(chessArr1);// 写入到文件
		// 稀疏数组恢复转换为原始的二维数组
		/**
		 * - 1）**先读取稀疏数组的第一行**，根据第一行的数据，**创建原始的二维数组**，比如上面的chessArr2=int [11][11] 
		 * -2）**再读取**稀疏数组**后几行的数据**，并**赋值给原始的二维数据即可**
		 */
		// 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组
		
		//方式一：使用IO流恢复二维数组
		System.out.println("使用IO流恢复二维数组：");
		int[][] readerArray = readerArray();
		printArray(readerArray);
		
		int[][] chessArr2 = new int[readerArray[0][0]][readerArray[0][1]];
		System.out.println("恢复的数组为：");
		// 2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.
		for (int i = 1; i < readerArray.length; i++) {
			chessArr2[readerArray[i][0]][readerArray[i][1]] = readerArray[i][2];
		}
		printArray(chessArr2);
		//方式二：直接读取的数组
		/*int[][] chessArr2 = new int[chessArr1[0][0]][chessArr1[0][1]];
		System.out.println("恢复的数组为：");
		// 2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.
		for (int i = 1; i < chessArr1.length; i++) {
			chessArr2[chessArr1[i][0]][chessArr1[i][1]] = chessArr1[i][2];
		}
		printArray(chessArr2);*/
	}

	/**
	 * 打印二维数组
	 * 
	 * @param printArray 要打印的二维数组
	 * @throws IOException
	 */
	public static void printArray(int[][] printArray) throws IOException {

		for (int[] row : printArray) {
			for (int data : row) {
				// \t 代表按一下tab键
				System.out.printf("%d\t", data);
			}
			System.out.println();
		}
	}

	/**
	 * 写入数组到文件
	 * @param printArray
	 * @throws IOException
	 */
	public static void writerArray(int[][] printArray) throws IOException {
		FileWriter fw = new FileWriter(new File("map.data"));
		for (int[] row : printArray) {
			StringBuilder sb = new StringBuilder("");
			for (int data : row) {
				// \t 代表按一下tab键
				//System.out.printf("%d\t", data);
				sb.append(data + "&");//添加分隔符&
			}
			sb.append("\n");
			fw.write(sb.toString());
			//System.out.println(sb.toString());
			//System.out.println();
		}
		fw.close();
	}
	
	/**
	 * 读取文件返回一个二维数组
	 * @return
	 * @throws IOException
	 */
	public static int[][] readerArray() throws IOException {
	FileReader fr=new FileReader(new File("map.data"));
	BufferedReader br=new BufferedReader(fr);
	String s=null;
	int count=0;
	while(br.readLine()!=null) {
		count++;
	}
	//System.out.println("count:"+count);//总行数
	int falg=0;
	int[][] resultArr=new int[count][3];
	FileReader fr1=new FileReader(new File("map.data"));
	BufferedReader br1=new BufferedReader(fr1);
	while((s=br1.readLine())!=null) {
		System.out.println(s);
		String[] split = s.split("&");
//		System.out.println("分隔后的数组为："+Arrays.deepToString(split));
		resultArr[falg]=stringToIntArr(split);
		falg++;
	}
	br.close();
	br1.close();
	return resultArr;
	}
	
	/**
	 * 将String一维数组转换为int 一维数组
	 * @param sArr
	 * @return
	 */
	public static int[] stringToIntArr(String [] sArr) {
		int[] intArr=new int[sArr.length];
		for (int i = 0; i < sArr.length; i++) {
			System.out.println("获取到的值："+sArr[i]);
			intArr[i]=Integer.parseInt(sArr[i]);
		}
		return intArr;
	}
}
```

## 3.2）队列

### 3.2.1）银行排队的案例:

<img src="images/10.png" alt="10" style="zoom:67%;" />



### 3.2.2）队列介绍

- 1）队列是一个**有序列表**，可以用**数组或是链表**来实现。
- 2）遵循**先入先出的原则**。即：先存入队列的数据，要先取出。后存入的要后取出
- 示意图：(使用数组模拟队列示意图)

![11](images/11.png)

### 3.2.3）数组模拟队列思路

- 1）队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 **maxSize 是该队列的最大容量。**
- 2）因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 **front及 rear分别记录队列前后端的下标**，**front 会随着数据输出而改变，而 rear则是随着数据输入而改变**，如图所示:

![11](images/11.png)

**代码实现的思路分析：**

- 3）当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：思路分析 
  - **将尾指针往后移：rear+1 , 当front == rear 【空】**
  - **若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear所指的数组元素中，否则无法存入数据。 rear  == maxSize - 1[队列满]**

### 3.2.4）数组模拟队列代码实现

```java
package com.wck.queue;

import java.util.Scanner;

public class ArrayQueueDemo {

	public static void main(String[] args) {
		//测试一把
				//创建一个队列
				ArrayQueue queue = new ArrayQueue(3);
				char key = ' '; //接收用户输入
				Scanner scanner = new Scanner(System.in);//
				boolean loop = true;
				//输出一个菜单
				while(loop) {
					System.out.println("s(show): 显示队列");
					System.out.println("e(exit): 退出程序");
					System.out.println("a(add): 添加数据到队列");
					System.out.println("g(get): 从队列取出数据");
					System.out.println("h(head): 查看队列头的数据");
					key = scanner.next().charAt(0);//接收一个字符
					switch (key) {
					case 's':
						queue.showQueue();
						break;
					case 'a':
						System.out.println("输出一个数");
						int value = scanner.nextInt();
						queue.addQueue(value);
						break;
					case 'g': //取出数据
						try {
							int res = queue.getQueue();
							System.out.printf("取出的数据是%d\n", res);
						} catch (Exception e) {
							// TODO: handle exception
							System.out.println(e.getMessage());
						}
						break;
					case 'h': //查看队列头的数据
						try {
							int res = queue.headQueue();
							System.out.printf("队列头的数据是%d\n", res);
						} catch (Exception e) {
							// TODO: handle exception
							System.out.println(e.getMessage());
						}
						break;
					case 'e': //退出
						scanner.close();
						loop = false;
						break;
					default:
						break;
					}
				}
				System.out.println("程序退出~~");
	}
}
//使用数组模拟队列，编写一个ArrayQueue类
class ArrayQueue{
	private int maxSize;//表示数组的最大容量
	private int front;//队列头
	private int rear;//队列尾
	private int[] arr;//用于存放队列的数组
	/**
	 * 
	 * @param maxSize 传入数组队列的大小
	 */
	public ArrayQueue(int maxSize) {
		this.maxSize=maxSize;
		this.front=-1;//指向队列的头部，分析出front是指向队列头的前一个位置
		this.rear=-1;//指向队列的尾部，指向队列尾的数组，（即就是队列最后一个数据）
		arr=new int[maxSize];
	}
	//判断队列是否已经满
	public boolean isFull() {
		return rear==maxSize-1;
	}
	//判断队列是否为空
	public boolean isEmpty() {
		return front==rear;
	}
	/**
	 * 
	 * @param n 加入队列的数据
	 */
	public void addQueue(int n) {
		//判断队列是否已经满
		if(isFull()) {
			System.out.println("队列满，不能加入数据！");
			return;
		}
		rear++;//队尾加1
		arr[rear]=n;//加入数据到队列
	}
	/**
	 * 获取队列的值
	 * @return
	 */
	public int getQueue() {
		//判断队列是否为空
		if(isEmpty()) {
			//
			throw new RuntimeException("队列空不能取数据！");
		}
		front++;//取数据front加一
		return arr[front];//返回数据
	}
	/**
	 * 打印队列
	 */
	public void showQueue() {
		if (isEmpty()) {
			System.out.println("showQueue队列为空！没有数据");
		}
		//遍历输出队列
		for (int i = 0; i < arr.length; i++) {
			System.out.printf("arr[%d]=%d\n",i,arr[i]);
		}	
	}
	/**
	 * 查看队列的头数据
	 * @return
	 */
	public int headQueue() {
		//判断是否为空
		if(isEmpty()) {
			throw new RuntimeException("headQueue队列为空！没有数据");
		}
		System.out.println("当前的front为："+front);	
		return arr[front+1];
	}
}
```

### 3.2.5）问题分析并优化

- 1）目前数组使用一次就不能使用了，没有重复利用的效果
- 2）将这个数组使用算法，**改进成一个环形的队列 使用  % ：取模**

### 3.2.6）数组模拟环形队列

对前面的数组模拟队列的优化，充分利用数组. 因此**将数组看做是一个环形的**。(**通过取模的方式来实现即可**)

**分析说明：**

- 尾索引的下一个为头索引时表示队列满，**即将队列容量空出一个作为约定**,这个在做判断队列满的时候需要注意 (rear + 1) % maxSize == front 【满】 rear == front 【空】
- 之前的分析示意图:

![11](images/11.png)

**思路如下：**

- 1）**front 变量的含义做了调整**，**front 指向队列的第一个元素，也就是说arr\[front\]就是队列的第一个元素，front的初始值为0**

- 2）**rear变量的含义做了调整**，**rear指向队列的最后一个元素的后一个位置，因为希望腾出一个空闲的空间作为约定，rear的初始值为 0**

- 3）**当队列满的时候，条件为 (rear+1)%maxSize == front 为\[满\]**
- 4）**当队列为空的时候，条件为 rear==front \[空\]**

- 5）**当我们这样分析，队列中的有效的数据个数为（rear-front+maxSize）% maxSize**  
- 6）我们就可以在原先的队列基础上修改为环形队列

### 3.2.7）代码实现

**表格分析**：         

**maxSize 为4 ,rear  为 ：0 front 为：0**

![12](images/12.png)

**入队满->全出队**

| 出/入队  | arr\[\]值  | rear | front |
| -------- | ---------- | ---- | ----- |
| 初始状态 |            | 0    | 0     |
| 入队     | arr\[0\]=3 | 1    | 0     |
| 入队     | arr\[1\]=2 | 2    | 0     |
| 入队     | arr\[2\]=1 | 3    | 0     |
| 出队     | arr\[0\]=3 | 3    | 1     |
| 出队     | arr\[1\]=2 | 3    | 2     |
| 出队     | arr\[2\]=1 | 3    | 3     |



**入队->出队->入队（超出最大索引的情况）**

| 出/入队  | arr[]值    | rear | front |
| -------- | ---------- | ---- | ----- |
| 初始状态 |            | 0    | 0     |
| 入队     | arr\[0\]=3 | 1    | 0     |
| 入队     | arr\[1\]=2 | 2    | 0     |
| 出队     | arr\[0\]=3 | 2    | 1     |
| 出队     | arr\[1\]=2 | 2    | 2     |
| 入队     | arr\[2\]=1 | 3    | 2     |
| 入队     | arr\[3\]=6 | 0    | 2     |
| 出队     | arr\[2\]=1 | 0    | 3     |
| 出队     | arr\[3\]=6 | 0    | 0     |

```java
package com.wck.queue;

import java.util.Scanner;

public class CircleArrayQueueDemo {
	public static void main(String[] args) {
		//测试一把
		//创建一个队列
		CircleArray queue = new CircleArray(4);
		char key = ' '; //接收用户输入
		Scanner scanner = new Scanner(System.in);//
		boolean loop = true;
		//输出一个菜单
		while(loop) {
			System.out.println("s(show): 显示队列");
			System.out.println("e(exit): 退出程序");
			System.out.println("a(add): 添加数据到队列");
			System.out.println("g(get): 从队列取出数据");
			System.out.println("h(head): 查看队列头的数据");
			key = scanner.next().charAt(0);//接收一个字符
			switch (key) {
			case 's':
				queue.showQueue();
				break;
			case 'a':
				System.out.println("输出一个数");
				int value = scanner.nextInt();
				queue.addQueue(value);
				break;
			case 'g': //取出数据
				try {
					int res = queue.getQueue();
					System.out.printf("取出的数据是%d\n", res);
				} catch (Exception e) {
					// TODO: handle exception
					System.out.println(e.getMessage());
				}
				break;
			case 'h': //查看队列头的数据
				try {
					int res = queue.headQueue();
					System.out.printf("队列头的数据是%d\n", res);
				} catch (Exception e) {
					// TODO: handle exception
					System.out.println(e.getMessage());
				}
				break;
			case 'e': //退出
				scanner.close();
				loop = false;
				break;
			default:
				break;
			}
		}
		System.out.println("程序退出~~");
	}
}
class CircleArray{
	private int maxSize;//表示数组的最大容量
	//front永远指向队列的头部
	//front的初始值 为 0
	private int front;
	//rear指向队列最后一个元素的后一个元素的位置，因为希望腾出一个空间作为约定
	//rear的初始值 为 0
	private int rear;
	private int[] arr;//用于存放队列的数组
	
	public CircleArray(int maxSize) {
		this.maxSize=maxSize;
		arr=new int[maxSize];
		//默认不赋值也是0
		//this.front=0;
		//默认不赋值也是0
		//this.rear=0;
	}
	//判断队列是否已经满
	public boolean isFull() {
		//此时的rear指的是 当前队尾的 值 后面的一个位置
		/**
		 * maxSize 为 4
		 * 则 当前的 arr[2]=1 //也就是当前的是 第三个值 此时 rear的值 为索引 （2+1） 为 3
		 * 则（3+1）%4 =0 ，此时队满，留了一个空闲的位置
		 */
		return (rear+1)%maxSize ==front;
	}
	
	//判断队列是否为空
	public boolean isEmpty() {
		//此时的front 和rear 都是取模后的值
		//即都是 front 和 rear 加1 后的值
		return front==rear;
	}
	
	/**
	 * 
	 * @param n 加入队列的数据
	 */
	public void addQueue(int n) {
		//判断队列是否已经满
		if(isFull()) {
			System.out.println("队列满，不能加入数据！");
			return;
		}
		//直接将数据加入
		arr[rear] = n;
		//将 rear 后移, 这里必须考虑取模
		rear = (rear + 1) % maxSize;
	}
	// 获取队列的数据, 出队列
	public int getQueue() {
		// 判断队列是否空
		if (isEmpty()) {
			// 通过抛出异常
			throw new RuntimeException("队列空，不能取数据");
		}
		// 这里需要分析出 front是指向队列的第一个元素
		// 1. 先把 front 对应的值保留到一个临时变量
		// 2. 将 front 后移, 考虑取模
		// 3. 将临时保存的变量返回
		int value = arr[front];
		front = (front + 1) % maxSize;
		return value;
	}
	/**
	 * 打印队列
	 */
	public void showQueue() {
		if (isEmpty()) {
			System.out.println("showQueue队列为空！没有数据");
			return ;
		}
		for(int i=front ;i < front +size();i++) {
			System.out.printf("arr[%d]=%d\n",i%maxSize,arr[i%maxSize]);
		}	
	}
	/**
	 * 获取当前队列中有效值得个数
	 * @return
	 */
	public int size() {
		return (rear-front+maxSize)%maxSize;
	}
	
	/**
	 * 查看队列的头数据
	 * @return
	 */
	public int headQueue() {
		//判断是否为空
		if(isEmpty()) {
			throw new RuntimeException("headQueue队列为空！没有数据");
		}
		System.out.println("当前的front为："+front);	
		return arr[front];
	}
}
```

















